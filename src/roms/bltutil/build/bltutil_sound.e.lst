ca65 V2.18 - Git edfda72a
Main file   : bltutil_sound.asm
Current file: bltutil_sound.asm

000000r 1               
000000r 1               		.include "oslib.inc"
000000r 2               ;	OS Entry points
000000r 2               
000000r 2               GSINIT					:=	$FFC2
000000r 2               GSREAD					:=	$FFC5
000000r 2               OSRDCH_NV				:=	$FFC8
000000r 2               OSWRCH_NV				:=	$FFCB
000000r 2               OSFIND					:=	$FFCE
000000r 2               OSGBPB					:=	$FFD1
000000r 2               OSBPUT					:=	$FFD4
000000r 2               OSBGET					:=	$FFD7
000000r 2               OSARGS					:=	$FFDA
000000r 2               OSFILE					:=	$FFDD
000000r 2               OSRDCH					:=	$FFE0
000000r 2               OSASCI					:=	$FFE3
000000r 2               OSNEWL					:=	$FFE7
000000r 2               OSWRCR					:=	$FFEC
000000r 2               OSWRCH					:=	$FFEE
000000r 2               OSWORD					:=	$FFF1
000000r 2               OSBYTE					:=	$FFF4
000000r 2               OSCLI					:=	$FFF7
000000r 2               
000000r 2               PRSTRING				:=	$FF9B
000000r 2               CLICOM					:=	$FFB9
000000r 2               ERRJMP					:=	$FFBC
000000r 2               OSINIT					:=	$FFBF
000000r 2               SCANHEX					:=	$FFA1
000000r 2               OSQUIT					:=	$FFA7
000000r 2               PRHEX					:=	$FFAA
000000r 2               PR2HEX					:=	$FFAD
000000r 2               USERINT					:=	$FFB0
000000r 2               PRTEXT					:=	$FFB3
000000r 2               
000000r 2               OSRDRM					:=	$FFB9
000000r 2               OSEVEN					:=	$FFBF
000000r 2               RAWVDU					:=	$FFCB
000000r 2               
000000r 2               DEBUGPRINTNEWL				:=	$FF8C
000000r 2               DEBUGPRINTHEX				:=	$FF8F
000000r 2               DEBUGPRINTA				:=	$FF92
000000r 2               DEBUGPRINTX				:=	$FF95
000000r 2               
000000r 2               ;	OS Constants
000000r 2               
000000r 2               ERR_FILE_NOT_FOUND			:= 214
000000r 2               
000000r 2               OSFILE_LOAD				:= $FF
000000r 2               OSFILE_SAVE				:= $00
000000r 2               OSFILE_SET_LOAD				:= $02
000000r 2               OSFILE_CAT				:= $05
000000r 2               OSFILE_OFS_FILENAME			:= $00
000000r 2               OSFILE_OFS_LOAD				:= $02
000000r 2               OSFILE_OFS_EXEC				:= $06
000000r 2               OSFILE_OFS_LEN				:= $0A
000000r 2               OSFILE_OFS_START			:= $0A
000000r 2               OSFILE_OFS_ATTR				:= $0E
000000r 2               OSFILE_OFS_END				:= $0E
000000r 2               OSFILE_TYPE_NOTFOUND			:= $00
000000r 2               OSFILE_TYPE_FILE			:= $01
000000r 2               OSFILE_TYPE_DIRECTORY			:= $02
000000r 2               
000000r 2               
000000r 2               OSFIND_CLOSE				:= $00
000000r 2               OSFIND_OPENIN				:= $40
000000r 2               OSFIND_OPENOUT				:= $80
000000r 2               OSFIND_OPENUP				:= $C0
000000r 2               
000000r 2               OSWORD_SOUND				:= $07
000000r 2               OSWORD_ENVELOPE				:= $08
000000r 2               
000000r 2               OSARGS_cmdtail				:= $01
000000r 2               OSARGS_EXT				:= $02
000000r 2               
000000r 2               OSGBPB_WRITE_PTR			:=	$00
000000r 2               OSGBPB_WRITE_NOPTR			:=	$02
000000r 2               OSGBPB_READ_PTR				:=	$03
000000r 2               OSGBPB_READ_NOPTR			:=	$04
000000r 2               OSGBPB_READ_TITLE			:=	$05
000000r 2               OSGBPB_READ_DIR				:=	$06
000000r 2               OSGBPB_READ_LIB				:=	$07
000000r 2               OSGBPB_GET_DIRENT			:=	$08
000000r 2               
000000r 2               
000000r 2               SERVICE_0_NOP				:=	$0
000000r 2               SERVICE_1_ABSWKSP_REQ			:=	$1
000000r 2               SERVICE_2_RELWKSP_REQ			:=	$2
000000r 2               SERVICE_3_AUTOBOOT			:=	$3
000000r 2               SERVICE_4_UKCMD				:=	$4
000000r 2               SERVICE_5_UKINT				:=	$5
000000r 2               SERVICE_6_BRK				:=	$6
000000r 2               SERVICE_7_UKOSBYTE			:=	$7
000000r 2               SERVICE_7_UKOSWORD			:=	$8
000000r 2               SERVICE_9_HELP				:=	$9
000000r 2               SERVICE_A_ABSWKSP_CLAIM			:=	$A
000000r 2               SERVICE_B_NMI_RELEASE			:=	$B
000000r 2               SERVICE_C_NMI_CLAIM			:=	$C
000000r 2               SERVICE_D_ROMFS_INIT			:=	$D
000000r 2               SERVICE_E_ROMFS_GETB			:=	$E
000000r 2               SERVICE_F_FSVEC_CLAIMED			:=	$F
000000r 2               SERVICE_10_SPOOL_CLOSE			:=	$10
000000r 2               SERVICE_11_FONT_BANG			:=	$11
000000r 2               SERVICE_12_INITFS			:=	$12
000000r 2               SERVICE_13_SERIAL_CHAR			:=	$13
000000r 2               SERVICE_14_PRINT_CHAR			:=	$14
000000r 2               SERVICE_15_100Hz			:=	$15
000000r 2               SERVICE_25_FSINFO			:=	$25
000000r 2               
000000r 2               FSCV_6_NewFS				:=	$06
000000r 2               
000000r 2               ; OS Vectors
000000r 2               
000000r 2               USERV					:=	$0200	; User vector, called by *LINE, *CODE, OSWORD >=&E0
000000r 2               BRKV					:=	$0202	; The BRK vector
000000r 2               IRQ1V					:=	$0204	; Main interrupt vector
000000r 2               IRQ2V					:=	$0206	; Secondary interrupt vector
000000r 2               CLIV					:=	$0208	; Command Line Interpreter vector
000000r 2               BYTEV					:=	$020A	; OSBYTE (*FX) calls
000000r 2               WORDV					:=	$020C	; OSWORD calls
000000r 2               WRCHV					:=	$020E	; Send character to current output stream
000000r 2               RDCHV					:=	$0210	; Wait for a character from current input stream
000000r 2               FILEV					:=	$0212	; Operate on a whole file, eg loading/saving/delete/etc
000000r 2               ARGSV					:=	$0214	; Read/Write arguments on an open file
000000r 2               BGETV					:=	$0216	; Read a byte from an open file
000000r 2               BPUTV					:=	$0218	; Write a byte to an open file
000000r 2               GBPBV					:=	$021A	; Read/Write block of data from/to open file or device
000000r 2               FINDV					:=	$021C	; Open or close a file
000000r 2               FSCV					:=	$021E	; Various filing system control calls
000000r 2               EVNTV					:=	$0220	; Event handler
000000r 2               UPTV					:=	$0222	; User Print vector
000000r 2               NETV					:=	$0224	; Network Print vector
000000r 2               VDUV					:=	$0226	; Unrecognised VDU commands
000000r 2               KEYV					:=	$0228	; Read the keyboard
000000r 2               INSV					:=	$022A	; Insert characters into a buffer
000000r 2               REMV					:=	$022C	; Remove characters from a buffer
000000r 2               CNPV					:=	$022E	; Count or Purge a buffer
000000r 2               ;;IND1V					:=	$0230	; Spare
000000r 2               SWI9V					:=	$0230	; SWI instruction vector - do not use except for debugging
000000r 2               ;;IND2V					:=	$0232	; Spare
000000r 2               SW29V					:=	$0232	; SWI2 vector, may be used by applications, though not recommnded
000000r 2               ;;IND3V					:=	$0234	; Spare
000000r 2               NMI9V					:=	$0234	; NMI vector - do not use except for debugging
000000r 2               
000000r 2               ; OS Extended Vectors Marker addresses
000000r 2               
000000r 2               EXTVEC_ENTER_USERV			:=	$FF00	; User vector, called by *LINE, *CODE, OSWORD >=&E0
000000r 2               EXTVEC_ENTER_BRKV			:=	$FF03	; The BRK vector
000000r 2               EXTVEC_ENTER_IRQ1V			:=	$FF06	; Main interrupt vector
000000r 2               EXTVEC_ENTER_IRQ2V			:=	$FF09	; Secondary interrupt vector
000000r 2               EXTVEC_ENTER_CLIV			:=	$FF0C	; Command Line Interpreter vector
000000r 2               EXTVEC_ENTER_BYTEV			:=	$FF0F	; OSBYTE (*FX) calls
000000r 2               EXTVEC_ENTER_WORDV			:=	$FF12	; OSWORD calls
000000r 2               EXTVEC_ENTER_WRCHV			:=	$FF15	; Send character to current output stream
000000r 2               EXTVEC_ENTER_RDCHV			:=	$FF18	; Wait for a character from current input stream
000000r 2               EXTVEC_ENTER_FILEV			:=	$FF1B	; Operate on a whole file, eg loading/saving/delete/etc
000000r 2               EXTVEC_ENTER_ARGSV			:=	$FF1E	; Read/Write arguments on an open file
000000r 2               EXTVEC_ENTER_BGETV			:=	$FF21	; Read a byte from an open file
000000r 2               EXTVEC_ENTER_BPUTV			:=	$FF24	; Write a byte to an open file
000000r 2               EXTVEC_ENTER_GBPBV			:=	$FF27	; Read/Write block of data from/to open file or device
000000r 2               EXTVEC_ENTER_FINDV			:=	$FF2A	; Open or close a file
000000r 2               EXTVEC_ENTER_FSCV			:=	$FF2D	; Various filing system control calls
000000r 2               EXTVEC_ENTER_EVNTV			:=	$FF30	; Event handler
000000r 2               EXTVEC_ENTER_UPTV			:=	$FF33	; User Print vector
000000r 2               EXTVEC_ENTER_NETV			:=	$FF36	; Network Print vector
000000r 2               EXTVEC_ENTER_VDUV			:=	$FF39	; Unrecognised VDU commands
000000r 2               EXTVEC_ENTER_KEYV			:=	$FF3C	; Read the keyboard
000000r 2               EXTVEC_ENTER_INSV			:=	$FF3F	; Insert characters into a buffer
000000r 2               EXTVEC_ENTER_REMV			:=	$FF42	; Remove characters from a buffer
000000r 2               EXTVEC_ENTER_CNPV			:=	$FF45	; Count or Purge a buffer
000000r 2               EXTVEC_ENTER_IND1V			:=	$FF48	; Spare
000000r 2               EXTVEC_ENTER_IND2V			:=	$FF4B	; Spare
000000r 2               EXTVEC_ENTER_IND3V			:=	$FF4E	; Spare
000000r 2               
000000r 2               EXT_USERV				:=	$0D9F	; User vector, called by *LINE, *CODE, OSWORD >=&E0
000000r 2               EXT_BRKV				:=	$0DA2	; The BRK vector
000000r 2               EXT_IRQ1V				:=	$0DA5	; Main interrupt vector
000000r 2               EXT_IRQ2V				:=	$0DA8	; Secondary interrupt vector
000000r 2               EXT_CLIV				:=	$0DAB	; Command Line Interpreter vector
000000r 2               EXT_BYTEV				:=	$0DAE	; OSBYTE (*FX) calls
000000r 2               EXT_WORDV				:=	$0DB1	; OSWORD calls
000000r 2               EXT_WRCHV				:=	$0DB4	; Send character to current output stream
000000r 2               EXT_RDCHV				:=	$0DB7	; Wait for a character from current input stream
000000r 2               EXT_FILEV				:=	$0DBA	; Operate on a whole file, eg loading/saving/delete/etc
000000r 2               EXT_ARGSV				:=	$0DBD	; Read/Write arguments on an open file
000000r 2               EXT_BGETV				:=	$0DC0	; Read a byte from an open file
000000r 2               EXT_BPUTV				:=	$0DC3	; Write a byte to an open file
000000r 2               EXT_GBPBV				:=	$0DC6	; Read/Write block of data from/to open file or device
000000r 2               EXT_FINDV				:=	$0DC9	; Open or close a file
000000r 2               EXT_FSCV				:=	$0DCC	; Various filing system control calls
000000r 2               EXT_EVNTV				:=	$0DCF	; Event handler
000000r 2               EXT_UPTV				:=	$0DD2	; User Print vector
000000r 2               EXT_NETV				:=	$0DD5	; Network Print vector
000000r 2               EXT_VDUV				:=	$0DD8	; Unrecognised VDU commands
000000r 2               EXT_KEYV				:=	$0DDB	; Read the keyboard
000000r 2               EXT_INSV				:=	$0DDE	; Insert characters into a buffer
000000r 2               EXT_REMV				:=	$0DE1	; Remove characters from a buffer
000000r 2               EXT_CNPV				:=	$0DE4	; Count or Purge a buffer
000000r 2               EXT_IND1V				:=	$0DE7	; Spare
000000r 2               EXT_IND2V				:=	$0DEA	; Spare
000000r 2               EXT_IND3V				:=	$0DED	; Spare
000000r 2               
000000r 2               EVENT_NUM_4_VSYNC			:= 	4
000000r 2               
000000r 2               OSBYTE_0_HOST_OS			:=	0
000000r 2               OSBYTE_13_DISABLE_EVENT			:=	13
000000r 2               OSBYTE_14_ENABLE_EVENT			:=	14
000000r 2               OSBYTE_15_FLUSH_INPUT			:=	15
000000r 2               OSBYTE_21_FLUSH_BUFFER			:=	21
000000r 2               OSBYTE_108_WRITE_SHADOW_STATE		:=	108
000000r 2               OSBYTE_119_CLOSE_SPOOL_AND_EXEC		:=	119
000000r 2               OSBYTE_126_ESCAPE_ACK			:=	126
000000r 2               OSBYTE_129_INKEY			:=	129
000000r 2               OSBYTE_135_GET_MODE			:=	135
000000r 2               OSBYTE_142_SERVICE_CALL			:=	143
000000r 2               OSBYTE_156_SERIAL_STATE			:=	156
000000r 2               OSBYTE_160_READ_VDU_VARIABLE		:=	160
000000r 2               OSBYTE_168_READ_ROM_POINTER_TABLE	:=	168
000000r 2               OSBYTE_171_ROMTAB			:=	170
000000r 2               OSBYTE_232_VAR_IRQ_MASK_SERIAL		:=	232
000000r 2               OSBYTE_234_VAR_TUBE			:=	234
000000r 2               OSBYTE_253_VAR_LAST_RESET		:=	253
000000r 2               
000000r 2               vduvar_ix_GRA_WINDOW			:= $00
000000r 2               vduvar_ix_GRA_WINDOW_LEFT		:= $00	; Current graphics window left column in pixels
000000r 2               vduvar_ix_GRA_WINDOW_BOTTOM		:= $02	; Current graphics window bottom row in pixels
000000r 2               vduvar_ix_GRA_WINDOW_RIGHT		:= $04	; Current graphics window right column in pixels
000000r 2               vduvar_ix_GRA_WINDOW_TOP		:= $06	; Current graphics window top row in pixels
000000r 2               vduvar_ix_TXT_WINDOW_LEFT		:= $08	; Current text window left hand column
000000r 2               vduvar_ix_TXT_WINDOW_BOTTOM		:= $09	; Current text window bottom row
000000r 2               vduvar_ix_TXT_WINDOW_RIGHT		:= $0A	; Current text window right hand column
000000r 2               vduvar_ix_TXT_WINDOW_TOP		:= $0B	; Current text window top column
000000r 2               vduvar_ix_GRA_ORG_EXT			:= $0C	; Current graphics origin in external coordinates
000000r 2               vduvar_ix_GRA_CUR_EXT			:= $10	; Current graphics cursor in external coordinates
000000r 2               vduvar_ix_GRA_CUR_INT_OLD		:= $14	; Old graphics cursor in external coordinates
000000r 2               vduvar_ix_TXT_CUR_X			:= $18	; Current text cursor X
000000r 2               vduvar_ix_TXT_CUR_Y			:= $19	; Current text cursor Y
000000r 2               vduvar_ix_GRA_CUR_CELL_LINE		:= $1A	; Line within current graphics cell of graphics cursor
000000r 2               vduvar_ix_VDU_Q_START			:= $1B
000000r 2               vduvar_ix_VDU_Q_END			:= $24	; end of VDU Q (well 1 after!)
000000r 2               vduvar_ix_GRA_CUR_INT			:= $24	; Current graphics cursor in internal coordinates
000000r 2               vduvar_ix_TEMP_8			:= $28	; Bitmap read from screen by OSBYTE 135, various coordinate routines
000000r 2               vduvar_ix_GRA_WKSP			:= $30	; Graphics workspace
000000r 2               vduvar_ix_6845_CURSOR_ADDR		:= $4A	; Text cursor address for 6845
000000r 2               vduvar_ix_TXT_WINDOW_WIDTH_BYTES	:= $4C	; Text window width in bytes
000000r 2               vduvar_ix_SCREEN_BOTTOM_HIGH		:= $4E	; High byte of bottom of screen memory
000000r 2               vduvar_ix_BYTES_PER_CHAR		:= $4F	; Bytes per character for current mode
000000r 2               vduvar_ix_6845_SCREEN_START		:= $50	; Screen display start address for 6845
000000r 2               vduvar_ix_BYTES_PER_ROW			:= $52	; Bytes per screen row
000000r 2               vduvar_ix_SCREEN_SIZE_HIGH		:= $54	; Screen memory size high byte
000000r 2               vduvar_ix_MODE				:= $55	; Current screen mode
000000r 2               vduvar_ix_MODE_SIZE			:= $56	; Memory map type: 0 - 20K, 1 - 16K, 2 - 10K, 3 - 8K, 4 - 1K
000000r 2               vduvar_ix_TXT_FORE			:= $57	; Foreground text colour
000000r 2               vduvar_ix_TXT_BACK			:= $58	; Background text colour
000000r 2               vduvar_ix_GRA_FORE			:= $59	; Foreground graphics colour
000000r 2               vduvar_ix_GRA_BACK			:= $5A	; Background graphics colour
000000r 2               vduvar_ix_GRA_PLOT_FORE			:= $5B	; Foreground plot mode
000000r 2               vduvar_ix_GRA_PLOT_BACK			:= $5C	; Background plot mode
000000r 2               vduvar_ix_VDU_VEC_JMP			:= $5D	; General VDU jump vector
000000r 2               vduvar_ix_CUR_START_PREV		:= $5F	; Cursor start register previous setting
000000r 2               vduvar_ix_COL_COUNT_MINUS1		:= $60	; Number logical colours -1
000000r 2               vduvar_ix_PIXELS_PER_BYTE_MINUS1	:= $61	; Pixels per byte -1 (zero if text only mode)
000000r 2               vduvar_ix_LEFTMOST_PIX_MASK		:= $62	; Leftmost pixel colour mask
000000r 2               vduvar_ix_RIGHTMOST_PIX_MASK		:= $63	; Rightmost pixel colour mask
000000r 2               vduvar_ix_TEXT_IN_CUR_X			:= $64	; Text input cursor X
000000r 2               vduvar_ix_TEXT_IN_CUR_Y			:= $65	; Text input cursor Y
000000r 2               vduvar_ix_MO7_CUR_CHAR			:= $66	; Teletext output cursor character
000000r 2               vduvar_ix_EXPLODE_FLAGS			:= $67	; Font explosion flags, b1=224-255 in RAM, b7=32-63 in RAM
000000r 2               vduvar_ix_FONT_LOC32_63			:= $68	; Font location, characters 32-63
000000r 2               vduvar_ix_FONT_LOC64_95			:= $69	; Font location, characters 64-95
000000r 2               vduvar_ix_FONT_LOC96_127		:= $6A	; Font location, characters 96-127
000000r 2               vduvar_ix_FONT_LOC128_159		:= $6B	; Font location, characters 128-159
000000r 2               vduvar_ix_FONT_LOC160_191		:= $6C	; Font location, characters 160-191
000000r 2               vduvar_ix_FONT_LOC192_223		:= $6D	; Font location, characters 192-223
000000r 2               vduvar_ix_FONT_LOC224_255		:= $6E	; Font location, characters 224-255
000000r 2               vduvar_ix_PALLETTE			:= $6F	; Palette for colours 0 to 15
000000r 2               
000000r 1               		.include "mosrom.inc"
000000r 2               	.IFNDEF __MOSROM_INC__
000000r 2               __MOSROM_INC__:
000000r 2               
000000r 2               ;; taken from 6809 version and edited down - these data should be used with care
000000r 2               
000000r 2               mos_MACHINE_TYPE_BYTE			:= $63
000000r 2               
000000r 2               ;; Address of MOS ROM base
000000r 2               MOSROMBASE				:= $C000
000000r 2               
000000r 2               
000000r 2               FSCV_CODE_OSCLI_UK			:= $03
000000r 2               
000000r 2               
000000r 2               zp_lang					:= $0000
000000r 2               zp_eco					:= $0090
000000r 2               zp_nmi					:= $00A0
000000r 2               L00A9					:= $00A9
000000r 2               zp_fs_s					:= $00B0
000000r 2               zp_fs_w					:= $00C0
000000r 2               zp_vdu_status				:= $00D0	; VDU Status as read by OSBYTE &75
000000r 2               zp_vdu_grpixmask			:= $00D1	; Graphics pixel mask
000000r 2               zp_vdu_txtcolourOR			:= $00D2	; Text colour OR mask
000000r 2               zp_vdu_txtcolourEOR			:= $00D3	; Text colour EOR mask
000000r 2               zp_vdu_gracolourOR			:= $00D4	; Graphics colour OR mask
000000r 2               zp_vdu_gracolourEOR			:= $00D5	; Graphics colour EOR mask
000000r 2               zp_vdu_gra_char_cell			:= $00D6	; Graphics character cell
000000r 2               zp_vdu_top_scanline			:= $00D8	; Top scan line
000000r 2               zp_vdu_wksp				:= $00DA	; Temporary workspace
000000r 2               ;;;;removed !zp_rom_mul			:= $00E0	; BBC, Electron: Row multiplication
000000r 2               zp_cfs_w				:= $00E2
000000r 2               zp_opt_val				:= $00E3	; DB? check
000000r 2               zp_mos_GSREAD_quoteflag			:= $00E4	; GSREAD quote flag
000000r 2               zp_mos_GSREAD_characc			:= $00E5	; GSREAD character accumulator
000000r 2               zp_mos_OS_wksp				:= $00E6	; General OS workspace
000000r 2               zp_mos_autorep_countdown		:= $00E7	; Auto repeat countdown timer
000000r 2               zp_mos_input_buf			:= $00E8	; Input buffer pointer for OSWORD 0
000000r 2               zp_mos_rs423timeout			:= $00EA	; RS423 timeout counter, unused if no RS423
000000r 2               zp_mos_cfs_critical			:= $00EB	; CFS/RFS 'critical' flag
000000r 2               zp_mos_keynumlast			:= $00EC	; Internal key number (last)
000000r 2               zp_mos_keynumfirst			:= $00ED	; Internal key number (first)
000000r 2               zp_mos_jimdevsave			:= $00EE	; Internal key number of character to be ignored by OSBYTE &79, also the 1MHz bus paging register
000000r 2               zp_mos_OSBW_A				:= $00EF	; OSBYTE/OSWORD A reg value
000000r 2               ;;;;
000000r 2               zp_mos_OSBW_X				:= $00F0	; OSBYTE/OSWORD X reg value
000000r 2               zp_mos_OSBW_Y				:= $00F1	; OSBYTE/OSWORD Y reg value
000000r 2               
000000r 2               zp_mos_txtptr				:= $00F2	; OS Text pointer (eg star commands and filenames)
000000r 2               zp_mos_curROM				:= $00F4	; Currently selected ROM
000000r 2               zp_mos_curPHROM				:= $00F5	; Current PHROM or RFS ROM number or OSRDSC/OSWRSC number
000000r 2               zp_mos_genPTR				:= $00F6	; PHROM/RFSROM/OSRDSC/OSWRSC pointer
000000r 2               zp_mos_X				:= $00F8	; BBC, Electron: Unused, Master: Soft key expansion pointer
000000r 2               zp_mos_OS_wksp2				:= $00FA	; General OS workspace, used by buffer access code in interrupts
000000r 2               zp_mos_INT_A				:= $00FC	; Interrupt Temp A reg store
000000r 2               zp_mos_error_ptr			:= $00FD	; Error message pointer, initially set to language version string
000000r 2               zp_mos_ESC_flag				:= $00FF	; Escape flag (bit 7)
000000r 2               
000000r 2               stack					:= $0100
000000r 2               STACKTOP				:= $0200
000000r 2               
000000r 2               sysvar_OSVARADDR			:= $0236	; fx166/7 &A6/7 Address of OS variables
000000r 2               sysvar_ROMPTRTAB			:= $0238	; fx168/9 &A8/9 Address of ROM pointer table
000000r 2               sysvar_ROMINFOTAB			:= $023A	; fx170/1 &AA/B Address of ROM info table
000000r 2               sysvar_KEYB_ADDRTRANS			:= $023C	; fx172/3 &AC/D Address of key translation table
000000r 2               sysvar_ADDRVDUVARS			:= $023E	; fx174/5 &AE/F Address of VDU variables
000000r 2               sysvar_CFSTOCTR				:= $0240	; fx176	  &B0	CFS timeout counter, decremented every frame flyback
000000r 2               sysvar_CURINSTREAM			:= $0241	; fx177	  &B1	Currently selected input stream set with FX2
000000r 2               sysvar_KEYB_SEMAPHORE			:= $0242	; fx178	  &B2	BBC, Master: Keyboard semaphore
000000r 2               sysvar_PRI_OSHWM			:= $0243	; fx179	  &B3	Primary OSHWM
000000r 2               sysvar_CUR_OSHWM			:= $0244	; fx180	  &B4	Current OSHWM
000000r 2               sysvar_RS423_MODE			:= $0245	; fx181	  &B5	RS423 mode
000000r 2               sysvar_EXPLODESTATUS			:= $0246	; fx182	  &B6	BBC, Electron: Character definition explosion status
000000r 2               sysvar_CFSRFS_SWITCH			:= $0247	; fx183	  &B7	CFS/RFS switch
000000r 2               sysvar_VIDPROC_CTL_COPY			:= $0248	; fx184	  &B8	BBC, Master: RAM copy of VIDPROC control register
000000r 2               sysvar_VIDPROC_PAL_COPY			:= $0249	; fx185	  &B9	BBC, Master: RAM copy of VIDPROC palette register
000000r 2               sysvar_ROMNO_ATBREAK			:= $024A	; fx186	  &BA	ROM active last BRK
000000r 2               sysvar_ROMNO_BASIC			:= $024B	; fx187	  &BB	BASIC ROM number
000000r 2               sysvar_ADC_CUR				:= $024C	; fx188	  &BC	Current ADC Channel
000000r 2               sysvar_ADC_MAX				:= $024D	; fx189	  &BD	Maximum ADC Channel number
000000r 2               sysvar_ADC_ACCURACY			:= $024E	; fx190	  &BE	ADC conversion type/accuracy
000000r 2               sysvar_RS423_USEFLAG			:= $024F	; fx191	  &BF	RS423 use flag
000000r 2               sysvar_RS423_CTL_COPY			:= $0250	; fx192	  &C0	RAM copy of RS423 control register
000000r 2               sysvar_FLASH_CTDOWN			:= $0251	; fx193	  &C1	Flashing colour countdown timer
000000r 2               sysvar_FLASH_SPACE_PERIOD		:= $0252	; fx194	  &C2	Flashing colour space period count set by FX9
000000r 2               sysvar_FLASH_MARK_PERIOD		:= $0253	; fx195	  &C3	Flashing colour mark period count set by FX10
000000r 2               sysvar_KEYB_AUTOREP_DELAY		:= $0254	; fx196	  &C4	Keyboard auto-repeat delay set by FX11
000000r 2               sysvar_KEYB_AUTOREP_PERIOD		:= $0255	; fx197	  &C5	Keyboard auto-repeat period set by FX12
000000r 2               sysvar_EXEC_FILE			:= $0256	; fx198	  &C6	*EXEC file
000000r 2               sysvar_SPOOL_FILE			:= $0257	; fx199	  &C7	*SPOOL file handle
000000r 2               sysvar_BREAK_EFFECT			:= $0258	; fx200	  &C8	ESCAPE, BREAK effect
000000r 2               sysvar_KEYB_DISABLE			:= $0259	; fx201	  &C9	Keyboard disable
000000r 2               sysvar_KEYB_STATUS			:= $025A	; fx202	  &CA	Keyboard status byte
000000r 2               							;Bit 7  =1 shift enabled
000000r 2               							;Bit 6  =1 control pressed
000000r 2               							;bit 5  =0 shift lock
000000r 2               							;Bit 4  =0 Caps lock
000000r 2               							;Bit 3  =1 shift pressed
000000r 2               
000000r 2               sysvar_RS423_BUF_EXT			:= $025B	; fx203	  &CB	BBC, Master: Serial input buffer extent
000000r 2               sysvar_RS423_SUPPRESS			:= $025C	; fx204	  &CC	BBC, Master: Serial input supression flag
000000r 2               sysvar_RS423CASS_SELECT			:= $025D	; fx205	  &CD	BBC, Master: Serial/cassette selection flag
000000r 2               sysvar_ECO_OSBW_INTERCEPT		:= $025E	; fx206	  &CE	Econet OSBYTE/OSWORD intercept flag
000000r 2               sysvar_ECO_OSRDCH_INTERCEPT		:= $025F	; fx207	  &CF	Econet OSRDCH intercept flag
000000r 2               sysvar_ECO_OSWRCH_INTERCEPT		:= $0260	; fx208	  &D0	Econet OSWRCH intercept flag
000000r 2               sysvar_SPEECH_SUPPRESS			:= $0261	; fx209	  &D1	Speech suppression status
000000r 2               sysvar_SOUND_SUPPRESS			:= $0262	; fx210	  &D2	Sound suppression status
000000r 2               sysvar_BELL_CH				:= $0263	; fx211	  &D3	BELL channel number
000000r 2               sysvar_BELL_ENV				:= $0264	; fx212	  &D4	BELL envelope number/amplitude
000000r 2               sysvar_BELL_FREQ			:= $0265	; fx213	  &D5	BELL frequency
000000r 2               sysvar_BELL_DUR				:= $0266	; fx214	  &D6	BELL duration
000000r 2               sysvar_STARTUP_DISPOPT			:= $0267	; fx215	  &D7	Startup display and BOOT error options
000000r 2               sysvar_KEYB_SOFTKEY_LENGTH		:= $0268	; fx216	  &D8	Soft key string length
000000r 2               sysvar_SCREENLINES_SINCE_PAGE		:= $0269	; fx217	  &D9	Screen lines since last page
000000r 2               sysvar_VDU_Q_LEN			:= $026A	; fx218	  &DA	256-number of items in VDU queue
000000r 2               sysvar_KEYB_TAB_CHAR			:= $026B	; fx219	  &DB	BBC, Master: TAB key character
000000r 2               sysvar_KEYB_ESC_CHAR			:= $026C	; fx220	  &DC	ESCAPE character
000000r 2               sysvar_KEYB_C0CF_INSERT_INT		:= $026D	; fx221	  &DD	Char &C0-&CF buffer insert interpretation
000000r 2               sysvar_KEYB_D0DF_INSERT_INT		:= $026E	; fx222	  &DE	Char &D0-&DF buffer insert interpretation
000000r 2               sysvar_KEYB_E0EF_INSERT_INT		:= $026F	; fx223	  &DF	Char &E0-&EF buffer insert interpretation
000000r 2               sysvar_KEYB_F0FF_INSERT_INT		:= $0270	; fx224	  &E0	Char &F0-&FF buffer insert interpretation
000000r 2               sysvar_KEYB_808F_INSERT_INT		:= $0271	; fx225	  &E1	Char &80-&8F buffer insert interpretation (FKey)
000000r 2               sysvar_KEYB_909F_INSERT_INT		:= $0272	; fx226	  &E2	Char &90-&9F buffer insert interpretation (Sh+FKey)
000000r 2               sysvar_KEYB_A0AF_INSERT_INT		:= $0273	; fx227	  &E3	Char &A0-&AF buffer insert interpretation (Ct+FKey)
000000r 2               sysvar_KEYB_B0BF_INSERT_INT		:= $0274	; fx228	  &E4	Char &B0-&BF buffer insert interpretation (Ct+Sh+FKey)
000000r 2               sysvar_KEYB_ESC_ACTION			:= $0275	; fx229	  &E5	ESCAPE key action
000000r 2               sysvar_KEYB_ESC_EFFECT			:= $0276	; fx230	  &E6	ESCAPE effects
000000r 2               sysvar_USERVIA_IRQ_MASK_CPY		:= $0277	; fx231	  &E7	User 6522 VIA IRQ mask
000000r 2               sysvar_ACIA_IRQ_MASK_CPY		:= $0278	; fx232	  &E8	6850 ACIA IRQ bit mask
000000r 2               sysvar_SYSVIA_IRQ_MASK_CPY		:= $0279	; fx233	  &E9	System 6522 VIA IRQ mask
000000r 2               sysvar_TUBE_PRESENT			:= $027A	; fx234	  &EA	Tube presence flag
000000r 2               sysvar_SPEECH_PRESENT			:= $027B	; fx235	  &EB	Speech processor presence flag
000000r 2               sysvar_OUTSTREAM_DEST			:= $027C	; fx236	  &EC	Output stream character destination, set with FX3
000000r 2               sysvar_KEY_CURSORSTAT			:= $027D	; fx237	  &ED	Cursor key status, set with FX4
000000r 2               sysvar_FX238				:= $027E	; fx238	  &EE	BBC, Electron: unused
000000r 2               sysvar_FX239				:= $027F	; fx239	  &EF	unused
000000r 2               sysvar_COUNTRY				:= $0280	; fx240	  &F0	Country code
000000r 2               sysvar_USERFLAG				:= $0281	; fx241	  &F1	User flag location, set with FX1
000000r 2               sysvar_SERPROC_CTL_CPY			:= $0282	; fx242	  &F2	BBC, Master: RAM copy of SERPROC control register
000000r 2               sysvar_TIMER_SWITCH			:= $0283	; fx243	  &F3	Timer switch state
000000r 2               sysvar_KEYB_SOFT_CONSISTANCY		:= $0284	; fx244	  &F4	Soft key consistancy flag
000000r 2               sysvar_PRINT_DEST			:= $0285	; fx245	  &F5	Printer destination, set with FX5
000000r 2               sysvar_PRINT_IGNORE			:= $0286	; fx246	  &F6	Printer ignore character, set with FX6
000000r 2               sysvar_BREAK_VECTOR_JMP			:= $0287	; fx247	  &F7	Break Intercept Vector JMP
000000r 2               sysvar_BREAK_VECTOR_LOW			:= $0288	; fx248	  &F8	Break Intercept Vector address low byte
000000r 2               sysvar_BREAK_VECTOR_HIGH		:= $0289	; fx249	  &F9	Break Intercept Vector address high byte
000000r 2               sysvar_SHADOW1				:= $028A	; fx250	  &FA	BBC, Electron: unused, unless shadow screen present
000000r 2               sysvar_SHADOW2				:= $028B	; fx251	  &FB	BBC, Electron: unused, unless shadow screen present
000000r 2               sysvar_CUR_LANG				:= $028C	; fx252	  &FC	Current language ROM
000000r 2               sysvar_BREAK_LAST_TYPE			:= $028D	; fx253	  &FD	Last BREAK type
000000r 2               sysvar_RAM_AVAIL			:= $028E	; fx254	  &FE	BBC: Available RAM
000000r 2               sysvar_STARTUP_OPT			:= $028F	; fx255	  &FF	Startup options
000000r 2               oswksp_VDU_VERTADJ			:= $0290	; VDU vertical adjust, *TV first parameter
000000r 2               oswksp_VDU_INTERLACE			:= $0291	; Interlace toggle flag, *TV second parameter
000000r 2               oswksp_TIME				:= $0292	; TIME value 1, high byte...low byte
000000r 2               oswksp_TIME2				:= $0297	; TIME value 2, high byte...low byte
000000r 2               oswksp_OSWORD3_CTDOWN			:= $029C	; OSWORD 3/4 Countdown interval timer value
000000r 2               oswksp_ROMTYPE_TAB			:= $02A1	; Paged ROM type table
000000r 2               oswksp_INKEY_CTDOWN			:= $02B1	; INKEY countdown timer
000000r 2               oswksp_OSWORD0_LINE_LEN			:= $02B3	; OSWORD 0 maximum line length
000000r 2               oswksp_OSWORD0_MIN_CH			:= $02B4	; OSWORD 0 minimum character
000000r 2               oswksp_OSWORD0_MAX_CH			:= $02B5	; OSWORD 0 maximum character
000000r 2               adc_CH1_LOW				:= $02B6	; Channel 1 ADC value low
000000r 2               adc_CH2_LOW				:= $02B7	; Channel 2 ADC value low
000000r 2               adc_CH3_LOW				:= $02B8	; Channel 3 ADC value low
000000r 2               adc_CH4_LOW				:= $02B9	; Channel 4 ADC value low
000000r 2               adc_CH1_HI				:= $02BA	; Channel 1 ADC value high
000000r 2               adc_CH2_HI				:= $02BB	; Channel 2 ADC value high
000000r 2               adc_CH3_HI				:= $02BC	; Channel 3 ADC value high
000000r 2               adc_CH4_HI				:= $02BD	; Channel 4 ADC value high
000000r 2               adc_CH_LAST				:= $02BE	; Last ADC channel converted
000000r 2               mosvar_EVENT_ENABLE			:= $02BF	; MOS Event enable flags
000000r 2               mosvar_SOFTKEY_PTR			:= $02C9	; Soft key expansion pointer
000000r 2               mosvar_KEYB_AUTOREPEAT_COUNT		:= $02CA	; First auto repeat count
000000r 2               mosvar_KEYB_TWOKEY_ROLLOVER		:= $02CB	; Two key rollover workspace
000000r 2               mosvar_SOUND_SEMAPHORE			:= $02CE	; Sound semaphore
000000r 2               mosbuf_buf_busy				:= $02CF	; Buffer busy flags
000000r 2               mosbuf_buf_start			:= $02D8	; Buffer start indexes
000000r 2               mosbuf_buf_end				:= $02E1	; Buffer end indexes
000000r 2               cfsrfs_BLK_SIZE				:= $02EA	; Block size
000000r 2               cfsrfs_BLK_FLAG				:= $02EC	; Block flag
000000r 2               cfsrfs_LAST_CHA				:= $02ED	; Last input character
000000r 2               osfile_ctlblk				:= $02EE	; OSFILE control blocks for *LOAD, *SAVE, *CREATE and *DELETE.
000000r 2               vduvars_start				:= $0300
000000r 2               vduvar_GRA_WINDOW			:= $0300
000000r 2               vduvar_GRA_WINDOW_LEFT			:= $0300	; Current graphics window left column in pixels
000000r 2               vduvar_GRA_WINDOW_BOTTOM		:= $0302	; Current graphics window bottom row in pixels
000000r 2               vduvar_GRA_WINDOW_RIGHT			:= $0304	; Current graphics window right column in pixels
000000r 2               vduvar_GRA_WINDOW_TOP			:= $0306	; Current graphics window top row in pixels
000000r 2               vduvar_TXT_WINDOW_LEFT			:= $0308	; Current text window left hand column
000000r 2               vduvar_TXT_WINDOW_BOTTOM		:= $0309	; Current text window bottom row
000000r 2               vduvar_TXT_WINDOW_RIGHT			:= $030A	; Current text window right hand column
000000r 2               vduvar_TXT_WINDOW_TOP			:= $030B	; Current text window top column
000000r 2               vduvar_GRA_ORG_EXT			:= $030C	; Current graphics origin in external coordinates
000000r 2               vduvar_GRA_CUR_EXT			:= $0310	; Current graphics cursor in external coordinates
000000r 2               vduvar_GRA_CUR_INT_OLD			:= $0314	; Old graphics cursor in external coordinates
000000r 2               vduvar_TXT_CUR_X			:= $0318	; Current text cursor X
000000r 2               vduvar_TXT_CUR_Y			:= $0319	; Current text cursor Y
000000r 2               vduvar_GRA_CUR_CELL_LINE		:= $031A	; Line within current graphics cell of graphics cursor
000000r 2               vduvar_VDU_Q_START			:= $031B
000000r 2               vduvar_VDU_Q_END			:= $0324	; end of VDU Q (well 1 after!)
000000r 2               vduvar_GRA_CUR_INT			:= $0324	; Current graphics cursor in internal coordinates
000000r 2               vduvar_TEMP_8				:= $0328	; Bitmap read from screen by OSBYTE 135, various coordinate routines
000000r 2               vduvar_GRA_WKSP				:= $0330	; Graphics workspace
000000r 2               vduvar_6845_CURSOR_ADDR			:= $034A	; Text cursor address for 6845
000000r 2               vduvar_TXT_WINDOW_WIDTH_BYTES		:= $034C	; Text window width in bytes
000000r 2               vduvar_SCREEN_BOTTOM_HIGH		:= $034E	; High byte of bottom of screen memory
000000r 2               vduvar_BYTES_PER_CHAR			:= $034F	; Bytes per character for current mode
000000r 2               vduvar_6845_SCREEN_START		:= $0350	; Screen display start address for 6845
000000r 2               vduvar_BYTES_PER_ROW			:= $0352	; Bytes per screen row
000000r 2               vduvar_SCREEN_SIZE_HIGH			:= $0354	; Screen memory size high byte
000000r 2               vduvar_MODE				:= $0355	; Current screen mode
000000r 2               vduvar_MODE_SIZE			:= $0356	; Memory map type: 0 - 20K, 1 - 16K, 2 - 10K, 3 - 8K, 4 - 1K
000000r 2               vduvar_TXT_FORE				:= $0357	; Foreground text colour
000000r 2               vduvar_TXT_BACK				:= $0358	; Background text colour
000000r 2               vduvar_GRA_FORE				:= $0359	; Foreground graphics colour
000000r 2               vduvar_GRA_BACK				:= $035A	; Background graphics colour
000000r 2               vduvar_GRA_PLOT_FORE			:= $035B	; Foreground plot mode
000000r 2               vduvar_GRA_PLOT_BACK			:= $035C	; Background plot mode
000000r 2               vduvar_VDU_VEC_JMP			:= $035D	; General VDU jump vector
000000r 2               vduvar_CUR_START_PREV			:= $035F	; Cursor start register previous setting
000000r 2               vduvar_COL_COUNT_MINUS1			:= $0360	; Number logical colours -1
000000r 2               vduvar_PIXELS_PER_BYTE_MINUS1		:= $0361	; Pixels per byte -1 (zero if text only mode)
000000r 2               vduvar_LEFTMOST_PIX_MASK		:= $0362	; Leftmost pixel colour mask
000000r 2               vduvar_RIGHTMOST_PIX_MASK		:= $0363	; Rightmost pixel colour mask
000000r 2               vduvar_TEXT_IN_CUR_X			:= $0364	; Text input cursor X
000000r 2               vduvar_TEXT_IN_CUR_Y			:= $0365	; Text input cursor Y
000000r 2               vduvar_MO7_CUR_CHAR			:= $0366	; Teletext output cursor character
000000r 2               vduvar_EXPLODE_FLAGS			:= $0367	; Font explosion flags, b1=224-255 in RAM, b7=32-63 in RAM
000000r 2               vduvar_FONT_LOC32_63			:= $0368	; Font location, characters 32-63
000000r 2               vduvar_FONT_LOC64_95			:= $0369	; Font location, characters 64-95
000000r 2               vduvar_FONT_LOC96_127			:= $036A	; Font location, characters 96-127
000000r 2               vduvar_FONT_LOC128_159			:= $036B	; Font location, characters 128-159
000000r 2               vduvar_FONT_LOC160_191			:= $036C	; Font location, characters 160-191
000000r 2               vduvar_FONT_LOC192_223			:= $036D	; Font location, characters 192-223
000000r 2               vduvar_FONT_LOC224_255			:= $036E	; Font location, characters 224-255
000000r 2               vduvar_PALLETTE				:= $036F	; Palette for colours 0 to 15
000000r 2               
000000r 2               fsvar_seq_block_gap			:= $03D1
000000r 2               
000000r 2               ;********************************************************
000000r 2               ;*           B U F F E R   A D D R E S S E S            *
000000r 2               ;********************************************************
000000r 2               
000000r 2               BUFFER_KEYB_START			:= $03E0
000000r 2               BUFFER_KEYB_END				:= $03FF
000000r 2               BUFFER_SERI_START			:= $0A00
000000r 2               BUFFER_SERI_END				:= $0AFF
000000r 2               BUFFER_SERO_START			:= $0900
000000r 2               BUFFER_SERO_END				:= $09BF
000000r 2               BUFFER_LPT_START			:= $0880
000000r 2               BUFFER_LPT_END				:= $08BF
000000r 2               BUFFER_SND0_START			:= $0840
000000r 2               BUFFER_SND0_END				:= $084F
000000r 2               BUFFER_SND1_START			:= $0850
000000r 2               BUFFER_SND1_END				:= $085F
000000r 2               BUFFER_SND2_START			:= $0860
000000r 2               BUFFER_SND2_END				:= $086F
000000r 2               BUFFER_SND3_START			:= $0870
000000r 2               BUFFER_SND3_END				:= $087F
000000r 2               BUFFER_SPCH_START			:= $09C0
000000r 2               BUFFER_SPCH_END				:= $09FF
000000r 2               
000000r 2               
000000r 2               snd_unused1				:= $800	; Unused
000000r 2               snd_q_occupied				:= $804	; Sound queue occupancy flag
000000r 2               snd_amplitude				:= $808	; Current amplitude
000000r 2               snd_amplitude_phase_count		:= $80C	; Number of amplitude phases processed
000000r 2               snd_abs_pitch				:= $810	; Absolute pitch value
000000r 2               snd_pitch_phase_count			:= $814	; Number of pitch phases processed
000000r 2               snd_steps_left				:= $818	; Number of steps to process
000000r 2               snd_duration_ctr			:= $81C	; Duration
000000r 2               snd_duration_mul			:= $820	; Interval multiplier
000000r 2               snd_env_no				:= $824	; Envelope number/auto repeat parameter
000000r 2               snd_length_left				:= $828	; Length of remaining note interval
000000r 2               snd_sync_hold_parm			:= $82C	; Sync hold parameter
000000r 2               snd_chip_pitch				:= $830	; Sound chip current pitch setting
000000r 2               snd_pitch_deviation			:= $834	; Pitch deviation
000000r 2               snd_num_chans_sync			:= $838	; Number of channels required for sync
000000r 2               snd_cur_amp_step			:= $839	; Current amplitude step
000000r 2               snd_cur_target_amplitude		:= $83A	; Current target amplitude
000000r 2               snd_num_chans_hold_sync			:= $83B	; Number of channels on hold for sync
000000r 2               
000000r 2               snd_parm_wksp				:= $83C	; Sound parameter calculation workspace
000000r 2               snd_low_parm				:= $83D	; Low order frequency parameter as sent to the sound generator
000000r 2               snd_high_parm				:= $83E	; High order frequency parameter as sent to the sound generator
000000r 2               snd_tempx				:= $83F
000000r 2               
000000r 2               snd_envelope_defs			:= $8C0
000000r 2               snd_envelope_STEP			:= $8C0
000000r 2               snd_envelope_PI1			:= $8C1
000000r 2               snd_envelope_PI2			:= $8C2
000000r 2               snd_envelope_PI3			:= $8C3
000000r 2               snd_envelope_PN1			:= $8C4
000000r 2               snd_envelope_PN2			:= $8C5
000000r 2               snd_envelope_PN3			:= $8C6
000000r 2               snd_envelope_AA				:= $8C7
000000r 2               snd_envelope_AD				:= $8C8
000000r 2               snd_envelope_AS				:= $8C9
000000r 2               snd_envelope_AR				:= $8CA
000000r 2               snd_envelope_ALA			:= $8CB
000000r 2               snd_envelope_ALD			:= $8CC
000000r 2               
000000r 2               
000000r 2               
000000r 2               soft_keys_start				:= $B00
000000r 2               
000000r 2               vec_nmi					:= $0D00
000000r 2               
000000r 2               swrom_wksp_tab				:= $0DF0
000000r 2               
000000r 2               	.ENDIF
000000r 2               
000000r 1               		.include "bltutil.inc"
000000r 2               		.include "hardware.inc"
000000r 3               	.IFNDEF __HARDWARE_INC__
000000r 3               __HARDWARE_INC__:
000000r 3               
000000r 3               
000000r 3               sheila_MEM_CTL			:= $FE31
000000r 3               BITS_MEM_CTL_SWMOS		:= $01
000000r 3               BITS_MEM_CTL_SWMOS_DEBUG	:= $04
000000r 3               BITS_MEM_CTL_SWMOS_DEBUG_EN	:= $08
000000r 3               BITS_MEM_CTL_FLEX		:= $10
000000r 3               BITS_MEM_CTL_SWMOS_DEBUG_5C	:= $40
000000r 3               BITS_MEM_CTL_SWMOS_DEBUG_ACT	:= $80
000000r 3               sheila_MEM_DEBUG_SAVE		:= $FE32
000000r 3               
000000r 3               sheila_MEM_TURBO2		:= $FE36
000000r 3               BITS_MEM_TURBO2_THROTTLE	:= $80
000000r 3               
000000r 3               sheila_MEM_LOMEMTURBO		:= $FE37
000000r 3               
000000r 3               
000000r 3               sheila_ACIA_CTL		:=	$FE08
000000r 3               ACIA_RDRF		:=	$01
000000r 3               ACIA_TDRE		:=	$02
000000r 3               
000000r 3               sheila_ACIA_DATA	:=	$FE09
000000r 3               sheila_SERIAL_ULA	:=	$FE10
000000r 3               
000000r 3               
000000r 3               ; BLTCON is written in two passes with top bit clear i.e. not BLTCON_ACT_ACT
000000r 3               ; the exec flags are first set
000000r 3               ; then with top bit set the active flag, bit mode and cell flags are set
000000r 3               ; BLTCON/ACT byte flags
000000r 3               
000000r 3               BLITCON_ACT_ACT			:=	$80		; always set when setting act constants/execing
000000r 3               BLITCON_ACT_CELL		:=	$40		; cell addressing used i.e. move one byte left adds 8 to address
000000r 3               							; moving one line down either adds 1 byte or STRIDE depending on whether
000000r 3               							; line crosses an 8 line boundary
000000r 3               BLITCON_ACT_MODE_1BBP		:=	$00		; 1 bit per pixel mapping 2 colours
000000r 3               BLITCON_ACT_MODE_2BBP		:=	$10		; 2 bit per pixel mapping 4 colours
000000r 3               BLITCON_ACT_MODE_4BBP		:=	$20		; 4 bit per pixel mapping 16 colours
000000r 3               BLITCON_ACT_MODE_8BBP		:=	$30		; 8 bit per pixel mapping 256 colours
000000r 3               BLITCON_ACT_LINE		:=	$08		; draw a line
000000r 3               BLITCON_ACT_COLLISION		:=	$04		; gets reset for any non-zero D data (even in EXEC_D is clear)
000000r 3               BLITCON_ACT_WRAP		:=	$02		; wrap C/D addresses to fit between min/max
000000r 3               
000000r 3               BLITCON_LINE_MAJOR_UPnRIGHT	:=	$10		; line draw major axis is up
000000r 3               BLITCON_LINE_MINOR_CCW		:=	$20		; minor axis is CCW to MAJOR i.e.:
000000r 3               							;  - left when maj up, up when maj right
000000r 3               							;  - otherwise, right when maj up, down when maj right
000000r 3               
000000r 3               BLITCON_EXEC_A			:=	$01
000000r 3               BLITCON_EXEC_B			:=	$02
000000r 3               BLITCON_EXEC_C			:=	$04
000000r 3               BLITCON_EXEC_D			:=	$08
000000r 3               BLITCON_EXEC_E			:=	$10
000000r 3               
000000r 3               AERIS_CTL_ACT			:=	$80
000000r 3               
000000r 3               ; DMA controller control flags
000000r 3               DMACTL_ACT			:=	$80		; always set to initiate a transfer
000000r 3               
000000r 3               DMACTL_EXTEND			:=	$20		; use extended functions from control2
000000r 3               DMACTL_HALT			:=	$10		; halt cpu during transfer
000000r 3               DMACTL_STEP_DEST_NONE		:=	$00		; do not step destination address
000000r 3               DMACTL_STEP_DEST_UP		:=	$04		; step destination up after transfer
000000r 3               DMACTL_STEP_DEST_DOWN		:=	$08		; step destination down after transfer
000000r 3               DMACTL_STEP_DEST_NOP		:=	$0C		; skip writes, do not increment address
000000r 3               DMACTL_STEP_SRC_NONE		:=	$00		; do not step destination address
000000r 3               DMACTL_STEP_SRC_UP		:=	$01		; step destination up after transfer
000000r 3               DMACTL_STEP_SRC_DOWN		:=	$02		; step destination down after transfer
000000r 3               DMACTL_STEP_SRC_NOP		:=	$03		; skip reads, do not incrememnt address
000000r 3               
000000r 3               DMACTL2_IF			:=	$80		; interrupt occurred
000000r 3               DMACTL2_IE			:=	$02		; interrupt enable, interrupt after transfer
000000r 3               DMACTL2_SZ_BYTE			:=	$00
000000r 3               DMACTL2_SZ_WORD			:=	$04
000000r 3               DMACTL2_SZ_WORDSWAPDEST		:=	$08
000000r 3               DMACTL2_SZ_WORDSWAPSRC		:=	$0C
000000r 3               DMACTL2_PAUSE			:=	$01
000000r 3               
000000r 3               ; Sound Status / control bits
000000r 3               SND_CTL_ACT			:=	$80
000000r 3               SND_CTL_REPEAT			:=	$01
000000r 3               
000000r 3               
000000r 3               DMAC_BLITCON_offs		:=	0
000000r 3               DMAC_FUNCGEN_offs		:=	$1
000000r 3               DMAC_WIDTH_offs			:=	$2
000000r 3               DMAC_HEIGHT_offs		:=	$3
000000r 3               DMAC_SHIFT_offs			:=	$4
000000r 3               DMAC_MASK_FIRST_offs		:=	$5
000000r 3               DMAC_MASK_LAST_offs		:=	$6
000000r 3               DMAC_DATA_A_offs		:=	$7
000000r 3               DMAC_ADDR_A_offs		:=	$8
000000r 3               DMAC_DATA_B_offs		:=	$B
000000r 3               DMAC_ADDR_B_offs		:=	$C
000000r 3               DMAC_ADDR_C_offs		:=	$F
000000r 3               DMAC_ADDR_D_offs		:=	$12
000000r 3               DMAC_ADDR_E_offs		:=	$15
000000r 3               DMAC_STRIDE_A_offs		:=	$18
000000r 3               DMAC_STRIDE_B_offs		:=	$1A
000000r 3               DMAC_STRIDE_C_offs		:=	$1C
000000r 3               DMAC_STRIDE_D_offs		:=	$1E
000000r 3               
000000r 3               DMAC_BLIT_EXT_offs		:=	$40
000000r 3               DMAC_ADDR_D_MIN_offs		:=	DMAC_BLIT_EXT_offs
000000r 3               DMAC_ADDR_D_MAX_offs		:=	DMAC_BLIT_EXT_offs+3
000000r 3               
000000r 3               
000000r 3               
000000r 3               DMAC_SND_DATA_offs		:=	$20
000000r 3               DMAC_SND_ADDR_offs		:=	$21
000000r 3               DMAC_SND_PERIOD_offs		:=	$24
000000r 3               DMAC_SND_LEN_offs		:=	$26
000000r 3               DMAC_SND_STATUS_offs		:=	$28
000000r 3               DMAC_SND_VOL_offs		:=	$29
000000r 3               DMAC_SND_REPOFF_offs		:=	$2A
000000r 3               DMAC_SND_PEAK_offs		:=	$2C
000000r 3               
000000r 3               DMAC_SND_MA_VOL_offs		:=	$2E
000000r 3               DMAC_SND_SEL_offs		:=	$2F
000000r 3               
000000r 3               DMAC_DMA_CTL_offs		:=	$30
000000r 3               DMAC_DMA_SRC_ADDR_offs		:=	$31
000000r 3               DMAC_DMA_DEST_ADDR_offs		:=	$34
000000r 3               DMAC_DMA_COUNT_offs		:=	$37
000000r 3               DMAC_DMA_DATA_offs		:=	$39
000000r 3               DMAC_DMA_CTL2_offs		:=	$3A
000000r 3               DMAC_DMA_PAUSE_VAL_offs		:=	$3B
000000r 3               DMAC_DMA_SEL_offs		:=	$3F
000000r 3               
000000r 3               
000000r 3               
000000r 3               DMAC_AERIS_CTL_offs		:=	$50
000000r 3               DMAC_AERIS_PROGBASE_offs	:=	$51
000000r 3               
000000r 3               
000000r 3               DMAC_I2C_offs		:=	$70
000000r 3               
000000r 3               jim_page_DMAC			:=	$FEFC
000000r 3               
000000r 3               jim_page_VERSION		:=	$FC00
000000r 3               
000000r 3               jim_offs_VERSION_API_level	:=	$80
000000r 3               jim_offs_VERSION_Board_level	:=	$81
000000r 3               jim_offs_VERSION_API_sublevel	:=	$82
000000r 3               jim_offs_VERSION_cfg_bits	:=	$84
000000r 3               jim_offs_VERSION_cap_bits	:=	$88
000000r 3               
000000r 3               ; Mk.2/1 option switches - note in API level >1 the sense of these is reversed!
000000r 3               BLT_MK2_CFG0_T65		:=	$01
000000r 3               BLT_MK2_CFG0_CPU_6502A_2M	:=	$00
000000r 3               BLT_MK2_CFG0_CPU_65C02_4M	:=	$02
000000r 3               BLT_MK2_CFG0_CPU_65C02_8M	:=	$04
000000r 3               BLT_MK2_CFG0_CPU_6x09_2M	:=	$08
000000r 3               BLT_MK2_CFG0_CPU_6309_4M	:=	$0A
000000r 3               BLT_MK2_CFG0_CPU_Z80_8M		:=	$0C
000000r 3               BLT_MK2_CFG0_CPU_68008		:=	$0E
000000r 3               BLT_MK2_CFG0_SWROMX		:=	$10
000000r 3               BLT_MK2_CFG0_BUGBTN		:=	$80
000000r 3               
000000r 3               BLT_MK2_CFG1_MEMI		:=	$01
000000r 3               BLT_MK2_CFG1_BUGOUT		:=	$02
000000r 3               
000000r 3               ; Mk.3 switches from PORTF/G
000000r 3               BLT_MK3_CFG0_T65		:=	$08
000000r 3               BLT_MK3_CFG0_SWROMX		:=	$10
000000r 3               BLT_MK3_CFG0_MEMI		:=	$40
000000r 3               
000000r 3               
000000r 3               
000000r 3               jim_DMAC			:=	$FD60
000000r 3               jim_DMAC_BLITCON		:=	jim_DMAC + DMAC_BLITCON_offs
000000r 3               jim_DMAC_FUNCGEN		:=	jim_DMAC + DMAC_FUNCGEN_offs
000000r 3               jim_DMAC_WIDTH			:=	jim_DMAC + DMAC_WIDTH_offs
000000r 3               jim_DMAC_HEIGHT			:=	jim_DMAC + DMAC_HEIGHT_offs
000000r 3               jim_DMAC_SHIFT			:=	jim_DMAC + DMAC_SHIFT_offs
000000r 3               jim_DMAC_MASK_FIRST		:=	jim_DMAC + DMAC_MASK_FIRST_offs
000000r 3               jim_DMAC_MASK_LAST		:=	jim_DMAC + DMAC_MASK_LAST_offs
000000r 3               jim_DMAC_DATA_A			:=	jim_DMAC + DMAC_DATA_A_offs
000000r 3               jim_DMAC_ADDR_A			:=	jim_DMAC + DMAC_ADDR_A_offs
000000r 3               jim_DMAC_DATA_B			:=	jim_DMAC + DMAC_DATA_B_offs
000000r 3               jim_DMAC_ADDR_B			:=	jim_DMAC + DMAC_ADDR_B_offs
000000r 3               jim_DMAC_ADDR_C			:=	jim_DMAC + DMAC_ADDR_C_offs
000000r 3               jim_DMAC_ADDR_D			:=	jim_DMAC + DMAC_ADDR_D_offs
000000r 3               jim_DMAC_ADDR_E			:=	jim_DMAC + DMAC_ADDR_E_offs
000000r 3               jim_DMAC_STRIDE_A		:=	jim_DMAC + DMAC_STRIDE_A_offs
000000r 3               jim_DMAC_STRIDE_B		:=	jim_DMAC + DMAC_STRIDE_B_offs
000000r 3               jim_DMAC_STRIDE_C		:=	jim_DMAC + DMAC_STRIDE_C_offs
000000r 3               jim_DMAC_STRIDE_D		:=	jim_DMAC + DMAC_STRIDE_D_offs
000000r 3               jim_DMAC_ADDR_D_MIN		:=	jim_DMAC + DMAC_ADDR_D_MIN_offs
000000r 3               jim_DMAC_ADDR_D_MAX		:=	jim_DMAC + DMAC_ADDR_D_MAX_offs
000000r 3               
000000r 3               
000000r 3               
000000r 3               
000000r 3               jim_DMAC_SND_DATA		:= 	jim_DMAC + DMAC_SND_DATA_offs
000000r 3               jim_DMAC_SND_ADDR		:= 	jim_DMAC + DMAC_SND_ADDR_offs
000000r 3               jim_DMAC_SND_PERIOD		:= 	jim_DMAC + DMAC_SND_PERIOD_offs
000000r 3               jim_DMAC_SND_LEN		:= 	jim_DMAC + DMAC_SND_LEN_offs
000000r 3               jim_DMAC_SND_STATUS		:= 	jim_DMAC + DMAC_SND_STATUS_offs
000000r 3               jim_DMAC_SND_VOL		:= 	jim_DMAC + DMAC_SND_VOL_offs
000000r 3               jim_DMAC_SND_REPOFF		:= 	jim_DMAC + DMAC_SND_REPOFF_offs
000000r 3               jim_DMAC_SND_PEAK		:= 	jim_DMAC + DMAC_SND_PEAK_offs
000000r 3               
000000r 3               jim_DMAC_SND_SEL		:= 	jim_DMAC + DMAC_SND_SEL_offs
000000r 3               jim_DMAC_SND_MA_VOL		:= 	jim_DMAC + DMAC_SND_MA_VOL_offs
000000r 3               
000000r 3               jim_DMAC_DMA_CTL		:=	jim_DMAC + DMAC_DMA_CTL_offs
000000r 3               jim_DMAC_DMA_SRC_ADDR		:=	jim_DMAC + DMAC_DMA_SRC_ADDR_offs
000000r 3               jim_DMAC_DMA_DEST_ADDR		:=	jim_DMAC + DMAC_DMA_DEST_ADDR_offs
000000r 3               jim_DMAC_DMA_COUNT		:=	jim_DMAC + DMAC_DMA_COUNT_offs
000000r 3               jim_DMAC_DMA_DATA		:=	jim_DMAC + DMAC_DMA_DATA_offs
000000r 3               jim_DMAC_DMA_CTL2		:=	jim_DMAC + DMAC_DMA_CTL2_offs
000000r 3               jim_DMAC_DMA_PAUSE_VAL		:=	jim_DMAC + DMAC_DMA_PAUSE_VAL_offs
000000r 3               jim_DMAC_DMA_SEL		:=	jim_DMAC + DMAC_DMA_SEL_offs
000000r 3               
000000r 3               jim_DMAC_AERIS_CTL		:=	jim_DMAC + DMAC_AERIS_CTL_offs
000000r 3               jim_DMAC_AERIS_PROGBASE		:=	jim_DMAC + DMAC_AERIS_PROGBASE_offs
000000r 3               
000000r 3               
000000r 3               jim_I2C_BASE			:= 	jim_DMAC + DMAC_I2C_offs
000000r 3               jim_I2C_STAT			:= 	jim_I2C_BASE
000000r 3               jim_I2C_DATA			:= 	jim_I2C_BASE + 1
000000r 3               
000000r 3               I2C_BUSY	:= $80
000000r 3               I2C_NACK	:= $40
000000r 3               I2C_STOP	:= $04
000000r 3               I2C_START	:= $02
000000r 3               I2C_RNW		:= $01
000000r 3               
000000r 3               sheila_sim_control		:=	$FEFF
000000r 3               sheila_reg_debug		:=	$FEFF
000000r 3               
000000r 3               fred_JIM_PAGE_HI2		:=	$FCFC		; note ignored Blitter/Paula
000000r 3               fred_JIM_PAGE_HI		:=	$FCFD
000000r 3               fred_JIM_PAGE_LO		:=	$FCFE
000000r 3               fred_JIM_DEVNO			:=	$FCFF
000000r 3               
000000r 3               jim_base			:=	$FD00
000000r 3               JIM				:=	jim_base
000000r 3               
000000r 3               SHEILA_ROMCTL_SWR	:=	$FE30
000000r 3               SHEILA_ROMCTL_MOS	:=	$FE31
000000r 3               
000000r 3               SHEILA_ROMCTL_SWR_ELK	:=	$FE05
000000r 3               
000000r 3               
000000r 3               ROMCTL_BITS_FLEX	:=	$10
000000r 3               
000000r 3               ROMCTL_MOS_JIMEN	:=	$02
000000r 3               ROMCTL_MOS_SWMOS	:=	$01
000000r 3               
000000r 3               
000000r 3               SHEILA_NULA_CTLAUX	:=	$FE22
000000r 3               SHEILA_NULA_PALAUX	:=	$FE23
000000r 3               
000000r 3               SHEILA_DEBUG		:=	$FEFF
000000r 3               
000000r 3               
000000r 3               ;***********************************************************************
000000r 3               ;* System VIA                                                          *
000000r 3               ;***********************************************************************
000000r 3               sheila_SYSVIA_orb			:= $FE40
000000r 3               sheila_SYSVIA_ora			:= $FE41
000000r 3               sheila_SYSVIA_ddrb			:= $FE42
000000r 3               sheila_SYSVIA_ddra			:= $FE43
000000r 3               sheila_SYSVIA_t1cl			:= $FE44
000000r 3               sheila_SYSVIA_t1ch			:= $FE45
000000r 3               sheila_SYSVIA_t1ll			:= $FE46
000000r 3               sheila_SYSVIA_t1lh			:= $FE47
000000r 3               sheila_SYSVIA_t2cl			:= $FE48
000000r 3               sheila_SYSVIA_t2ch			:= $FE49
000000r 3               sheila_SYSVIA_sr			:= $FE4A
000000r 3               sheila_SYSVIA_acr			:= $FE4B
000000r 3               sheila_SYSVIA_pcr			:= $FE4C
000000r 3               sheila_SYSVIA_ifr			:= $FE4D
000000r 3               sheila_SYSVIA_ier			:= $FE4E
000000r 3               sheila_SYSVIA_ora_nh			:= $FE4F
000000r 3               
000000r 3               ;***********************************************************************
000000r 3               ;* SYS VIA - slow data bus RTC                                         *
000000r 3               ;***********************************************************************
000000r 3               
000000r 3               	.IFDEF MACH_CHIPKIT
000000r 3               BITS_RTC_AS_ON	:=		$88			; PB7
000000r 3               BITS_RTC_AS_OFF :=		$08			;
000000r 3               BITS_RTC_CS	:=		$04			; latch
000000r 3               BITS_RTC_DS	:=		$02			; latch
000000r 3               BITS_RTC_RnW	:=		$01			; latch
000000r 3               BITS_LAT_ON	:=		$08			; latch
000000r 3               
000000r 3               RTC_REG_SECONDS	:=		$0
000000r 3               RTC_REG_MINUTES	:=		$2
000000r 3               RTC_REG_HOURS	:=		$4
000000r 3               RTC_REG_DOW	:=		$6
000000r 3               RTC_REG_DAY	:=		$7
000000r 3               RTC_REG_MONTH	:=		$8
000000r 3               RTC_REG_YEAR	:=		$9
000000r 3               	.ENDIF
000000r 3               
000000r 3               
000000r 3               ;***********************************************************************
000000r 3               ;* User VIA                                                            *
000000r 3               ;***********************************************************************
000000r 3               sheila_USRVIA_orb			:= $FE60
000000r 3               sheila_USRVIA_ora			:= $FE61
000000r 3               sheila_USRVIA_ddrb			:= $FE62
000000r 3               sheila_USRVIA_ddra			:= $FE63
000000r 3               sheila_USRVIA_t1cl			:= $FE64
000000r 3               sheila_USRVIA_t1ch			:= $FE65
000000r 3               sheila_USRVIA_t1ll			:= $FE66
000000r 3               sheila_USRVIA_t1lh			:= $FE67
000000r 3               sheila_USRVIA_t2cl			:= $FE68
000000r 3               sheila_USRVIA_t2ch			:= $FE69
000000r 3               sheila_USRVIA_sr			:= $FE6A
000000r 3               sheila_USRVIA_acr			:= $FE6B
000000r 3               sheila_USRVIA_pcr			:= $FE6C
000000r 3               sheila_USRVIA_ifr			:= $FE6D
000000r 3               sheila_USRVIA_ier			:= $FE6E
000000r 3               sheila_USRVIA_ora_nh			:= $FE6F
000000r 3               
000000r 3               ;***********************************************************************
000000r 3               ;*  VIA constants                                                      *
000000r 3               ;***********************************************************************
000000r 3               
000000r 3               VIA_IFR_BIT_ANY				:= $80
000000r 3               VIA_IFR_BIT_T1				:= $40
000000r 3               VIA_IFR_BIT_T2				:= $20
000000r 3               VIA_IFR_BIT_CB1				:= $10
000000r 3               VIA_IFR_BIT_CB2				:= $08
000000r 3               VIA_IFR_BIT_SR				:= $04
000000r 3               VIA_IFR_BIT_CA1				:= $02
000000r 3               VIA_IFR_BIT_CA2				:= $01
000000r 3               
000000r 3               VIA_ACR_SHIFTMODE_0			:= $00
000000r 3               VIA_ACR_SHIFTMODE_1			:= $04
000000r 3               VIA_ACR_SHIFTMODE_2			:= $08
000000r 3               VIA_ACR_SHIFTMODE_3			:= $0C
000000r 3               VIA_ACR_SHIFTMODE_4			:= $10
000000r 3               VIA_ACR_SHIFTMODE_5			:= $14
000000r 3               VIA_ACR_SHIFTMODE_6			:= $18
000000r 3               VIA_ACR_SHIFTMODE_7			:= $1C
000000r 3               
000000r 3               VIA_ACR_T1_MASK				:= $C0
000000r 3               VIA_ACR_T1_CONT				:= $40
000000r 3               
000000r 3               
000000r 3               ;***********************************************************************
000000r 3               ;* BBC B/B+ WD177x                                                     *
000000r 3               ;***********************************************************************
000000r 3               
000000r 3               sheila_1770_dcontrol			:=	$FE80
000000r 3               sheila_1770_wdc_cmd			:=	$FE84
000000r 3               sheila_1770_wdc_trk			:=	$FE85
000000r 3               sheila_1770_wdc_sec			:=	$FE86
000000r 3               sheila_1770_wdc_dat			:=	$FE87
000000r 3               
000000r 3               W1770_DRVSEL_BIT_SEL0			:= $01
000000r 3               W1770_DRVSEL_BIT_SEL1			:= $02
000000r 3               W1770_DRVSEL_BIT_SIDE1			:= $04
000000r 3               W1770_DRVSEL_BIT_nDDEN			:= $08
000000r 3               W1770_DRVSEL_BIT_nMR			:= $20
000000r 3               
000000r 3               
000000r 3               ;***********************************************************************
000000r 3               ;* NEW API JIM DEVICE NOs                                              *
000000r 3               ;***********************************************************************
000000r 3               
000000r 3               
000000r 3               JIM_DEVNO_HOG1MPAULA			:= $D0
000000r 3               JIM_DEVNO_BLITTER			:= $D1
000000r 3               
000000r 3               	.ENDIF
000000r 3               
000000r 2               
000000r 2               NOICE_BRK_INST	:= 	$5C				; special BRK instruction for noice
000000r 2               
000000r 2               ADDR_ERRBUF	:=	$100				; base of stack!
000000r 2               PG_EEPROM_BASE	:=	$9000				; base phys/jim address of EEPROM is $90 0000
000000r 2               							; note: this is a second copy of the EEPROM which
000000r 2               							; also appears based at $80 0000
000000r 2               
000000r 2               OSWORD_BLTUTIL	:=	$99				; blutils #
000000r 2               
000000r 2               OSWORD_OP_ALLOC :=	$10
000000r 2               OSWORD_OP_FREE  :=	$11
000000r 2               
000000r 2               JIM_SCRATCH	:=	$00FD				; page address of scratch space
000000r 2               
000000r 2               ;offsets in scrarch page
000000r 2               SCR_JIMDEVSAVE	:=	$00				; belt and braces used in cases of a BRK
000000r 2               
000000r 2               OSWORD_BLTUTIL_FLAG_CURRENT	:= $80
000000r 2               OSWORD_BLTUTIL_FLAG_ALTERNATE	:= $40
000000r 2               OSWORD_BLTUTIL_FLAG_IGNOREMEMI	:= $20
000000r 2               OSWORD_BLTUTIL_FLAG_MAP1	:= $01
000000r 2               
000000r 2               OSWORD_BLTUTIL_RET_FLASH	:= $80			; if memory is chip flash
000000r 2               OSWORD_BLTUTIL_RET_SYS		:= $40			; bank also base set to FF 80xx
000000r 2               OSWORD_BLTUTIL_RET_MEMI		:= $20
000000r 2               OSWORD_BLTUTIL_RET_ISCUR	:= $02
000000r 2               OSWORD_BLTUTIL_RET_MAP1		:= $01
000000r 2               
000000r 2               .macro		VERSION_NAME
000000r 2               		.byte	"BLTUTIL"
000000r 2               .endmacro
000000r 2               
000000r 2               		;TODO : move these to autogen'd files? Agree version # with JGH
000000r 2               .macro		VERSION_BYTE
000000r 2               		.byte	3
000000r 2               .endmacro
000000r 2               
000000r 2               .macro		VERSION_STRING
000000r 2               		.byte	"0.05"
000000r 2               .endmacro
000000r 2               
000000r 2               .macro		M_ERROR
000000r 2               		jsr	BounceErrorOffStack
000000r 2               .endmacro
000000r 2               
000000r 2               .macro		TODO	error
000000r 2               		M_ERROR
000000r 2               		.byte	$FF
000000r 2               		.byte	error
000000r 2               		.byte	0
000000r 2               .endmacro
000000r 2               
000000r 2               .macro		CLAIMDEV
000000r 2               		jsr	jimClaimDev
000000r 2               .endmacro
000000r 2               
000000r 2               .macro		SJTE	serv, addr
000000r 2               		.byte	serv
000000r 2               		.byte	>(addr - 1)			; bytes here in order ready to be stacked then rts'd to
000000r 2               		.byte 	<(addr - 1)
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               zp_trans_tmp	:=	$A8				; transient command buffer
000000r 2               zp_trans_acc	:=	$AC				; 4 byte accumulator used in hex parsers
000000r 2               zp_tmp_ptr	:=	$AC				; !! NOTE: overlaps acc
000000r 2               
000000r 2               zp_SRCOPY_src	:=	zp_trans_tmp + 1
000000r 2               zp_SRCOPY_dest	:=	zp_trans_tmp + 0
000000r 2               zp_SRCOPY_flags	:=	zp_trans_tmp + 2		; when negative dest if a flash
000000r 2               
000000r 2               zp_ROMS_ctr	:=	zp_trans_tmp + 0
000000r 2               zp_ROMS_copyptr	:=	zp_trans_tmp + 1
000000r 2               zp_ROMS_flags	:=	zp_trans_tmp + 3
000000r 2               zp_ROMS_OS99ret	:=	zp_trans_acc + 2
000000r 2               zp_ROMS_bank	:=	zp_trans_acc + 3
000000r 2               
000000r 2               zp_ERASE_dest	:=	zp_trans_tmp + 0
000000r 2               zp_ERASE_flags	:=	zp_trans_tmp + 1
000000r 2               zp_ERASE_ctr	:=	zp_trans_tmp + 2
000000r 2               zp_ERASE_errct	:=	zp_trans_tmp + 3
000000r 2               zp_ERASE_bank	:=	zp_trans_tmp + 5
000000r 2               
000000r 2               zp_SRLOAD_dest	:=	zp_trans_tmp + 0
000000r 2               zp_SRLOAD_flags	:=	zp_trans_tmp + 1
000000r 2               zp_SRLOAD_ptr	:=	zp_trans_tmp + 2
000000r 2               zp_SRLOAD_tmpA	:=	zp_trans_tmp + 4		; note overlaps acc
000000r 2               zp_SRLOAD_bank	:=	zp_trans_tmp + 5		; note overlaps acc
000000r 2               
000000r 2               SRLOAD_buffer_page	:=	$30
000000r 2               
000000r 2               zp_mdump_addr	:=	zp_trans_tmp + 0
000000r 2               zp_mdump_end	:=	zp_trans_tmp + 4		; not overlaps acc
000000r 2               zp_mdump_cols	:=	zp_mos_txtptr			; allows 32 bit addressing
000000r 2               
000000r 2               ; we can claim to be a language here...well sort of...
000000r 2               ZP_NUKE_LBAS	:=	$0
000000r 2               ZP_NUKE_ERRPTR	:=	ZP_NUKE_LBAS + 0
000000r 2               ZP_NUKE_S_TOP	:=	ZP_NUKE_LBAS + 2
000000r 2               ZP_NUKE_ROMSF	:=	ZP_NUKE_LBAS + 4
000000r 2               ZP_NUKE_PREVLANG:=	ZP_NUKE_LBAS + 5
000000r 2               STR_NUKE_CMD	:=	$700
000000r 2               
000000r 2               zp_blturbo_old	:=	zp_trans_tmp + 0
000000r 2               zp_blturbo_new	:=	zp_trans_tmp + 1
000000r 2               zp_blturbo_ptr	:=	zp_trans_tmp + 2
000000r 2               zp_blturbo_fl	:=	zp_trans_tmp + 4
000000r 2               
000000r 2               
000000r 2               
000000r 2               
000000r 2               PAGE_ROMSCRATCH		:=	$0080
000000r 2               PAGE_SAMPLETBL		:=	$0081
000000r 2               PAGE_SOUNDWKSP		:=	$0083
000000r 2               PAGE_SOUNDBUFFERS	:=	$0084
000000r 2               PAGE_RAM_TOP_BLITTER	:=	$1C00			; note leave room for SWRAM!
000000r 2               PAGE_RAM_TOP_PAULA	:=	$0800
000000r 2               
000000r 2               
000000r 2               			; offsets within scratch space
000000r 2               SCRATCH_CHECKSUM	:=	$00			; not used currently (reset on break)
000000r 2               SCRATCH_HEAPTOP		:=	$04			; top of head / ram
000000r 2               SCRATCH_HEAPBOT		:=	$06			; bottom of heap / extent allocated to heap (may contain holes)
000000r 2               SCRATCH_HEAPLIM		:=	$08			; lower limit for heap, will not allocate below here
000000r 2               
000000r 2               SAMTBL_SZ	:=	8			; size of a table entry
000000r 2               SAMTBLOFFS_BASE :=	0			; page number of start of sample
000000r 2               SAMTBLOFFS_LEN  :=	2			; length in samples
000000r 2               SAMTBLOFFS_REPL :=	4			; repeat offset
000000r 2               SAMTBLOFFS_FLAGS:=	7
000000r 2               
000000r 2               
000000r 2               			; offsets within the sound workspace page at 8300
000000r 2               ; the following are all in the ROM workspace at JIM 00 8000
000000r 2               SNDWKSP_SOUNDFLAGS	:=	$00
000000r 2               SCR_FLAG_SND_EN		:=	$80			; enabled flag
000000r 2               
000000r 2               SND_BUFFER_NUMBER_0	:=	$14			; buffer numbers are $14..$1B for channels 0..7
000000r 2               SND_BUF_LEN		:=	21
000000r 2               SND_NUM_CHANS		:=	8
000000r 2               
000000r 2               SNDWKSP_OLDINSV		:=	$02
000000r 2               SNDWKSP_OLDREMV		:=	$04
000000r 2               SNDWKSP_OLDCNPV		:=	$06
000000r 2               SNDWKSP_OLDBYTEV	:=	$08
000000r 2               
000000r 2               SNDWKDP_SCRATCH8	:=	$10			; 8 bytes of scratch space
000000r 2               
000000r 2               ; note the following need to be >SND_BUFFER_NUMBER_0 to avoid LDA nnn-$14,X tickling FRED
000000r 2               SNDWKSP_BUF_BUSY_0	:=	$20			; 1 byte for each channel - shows if there is stuff in the buffer
000000r 2               SNDWKSP_BUF_OUT_0	:=	$28			; 1 byte for each channel - pointer into buffer
000000r 2               SNDWKSP_BUF_IN_0	:=	$30			; 1 byte for each channel - pointer into buffer
000000r 2               SNDWKSP_ACTIVE		:=	$38			; sound channel active flags
000000r 2               
000000r 2               
000000r 2               
000000r 2               SNDWKSP_VAR_START		:= $40
000000r 2               SNDWKSP_QUEUE_OCC		:= $40
000000r 2               SNDWKSP_AMP_CUR			:= $48
000000r 2               SNDWKSP_AMP_PHASE_CUR		:= $50			; current amplitude phase of envelope 0..3
000000r 2               SNDWKSP_AMP_BASE_PITCH		:= $58
000000r 2               SNDWKSP_PITCH_PHASE_CUR		:= $60
000000r 2               SNDWKSP_PITCH_PH_STEPS		:= $68
000000r 2               SNDWKSP_DURATION		:= $70			; duration from SOUND command
000000r 2               SNDWKSP_DURATION_SUB		:= $78			; counts down from 5..0 to give 50ms per duration above
000000r 2               SNDWKSP_ENVELOPE_OFFS		:= $80			; offset into envelope or -1 for no envelope
000000r 2               SNDWKSP_ENV_STEPREPEAT		:= $88			; step length, b7=repeat flag
000000r 2               SNDWKSP_SYNC_FLAG		:= $90
000000r 2               SNDWKSP_SYNC_HOLD_PARAM		:= $98
000000r 2               SNDWKSP_PITCH_SETTING		:= $A0
000000r 2               SNDWKSP_PITCH_DEV		:= $A8
000000r 2               SNDWKSP_SAMPLE_NO		:= $B0
000000r 2               
000000r 2               SNDWKSP_SYNC_CHANS		:= $B8
000000r 2               SNDWKSP_AMP_STEP		:= $B9
000000r 2               SNDWKSP_AMP_TARGET		:= $BA
000000r 2               SNDWKSP_SYNC_HOLD_COUNT		:= $BB
000000r 2               SNDWKSP_WS_0			:= $BC
000000r 2               SNDWKSP_FREQ_LO			:= $BD
000000r 2               SNDWKSP_FREQ_HI			:= $BE
000000r 2               SNDWKSP_WS_3			:= $BF
000000r 2               SNDWKSP_DEF_SAM			:= $C0			; table of default sample numbers per channel 0..31|$80
000000r 2               SNDWKSP_VAR_END			:= $C8
000000r 2               
000000r 2               
000000r 2               SNDBUF_BUF_0		:=	$00			; sound buffers 21 bytes per channel
000000r 2               
000000r 2               
000000r 2               SCRATCH_TMP		:=	$80			; 128 bytes of scratch space for the current
000000r 2               							; command - do not use in service routines
000000r 2               
000000r 2               
000000r 1               		.include "bltutil_utils.inc"
000000r 2               
000000r 2               
000000r 2               		.import	BounceErrorOffStack
000000r 2               		.import PrintCommaSpace
000000r 2               		.import	Print2Spc
000000r 2               		.import	PrintSpc
000000r 2               		.import	PrintA
000000r 2               		.import	PrintNL
000000r 2               		.import	PrintHexA
000000r 2               		.import	PrintHexNybA
000000r 2               		.import	PrintHexXY
000000r 2               		.import	PrintMsgXYThenHexNyb
000000r 2               		.import	PrintXY
000000r 2               		.import	PrintPTR
000000r 2               		.import PrintImmed
000000r 2               		.import	PromptYN
000000r 2               		.import	PromptNo
000000r 2               		.import	PromptYes
000000r 2               		.import	PromptRTS
000000r 2               		.import PrintDec
000000r 2               		.import	WaitKey
000000r 2               		.import PrintBytesAndK
000000r 2               		.import PrintSizeK
000000r 2               
000000r 2               
000000r 2               		.import SkipSpacesPTR
000000r 2               		.import ToUpper
000000r 2               		.import parseONOFF
000000r 2               		.import parseONOFF_ck
000000r 2               		.import parseONOFF_ON
000000r 2               		.import ParseHex
000000r 2               		.import ParseHexLp
000000r 2               		.import ParseHexShAd
000000r 2               		.import ParseHexAlpha
000000r 2               		.import ParseHexErr
000000r 2               		.import ParseHexDone
000000r 2               		.import zeroAcc
000000r 2               		.import asl4Acc
000000r 2               		.import addAAcc
000000r 2               		.import div10Acc
000000r 2               		.import isAcc0
000000r 2               		.import PushAcc
000000r 2               		.import PopAcc
000000r 2               		.import StackAllocX
000000r 2               		.import StackFree
000000r 2               		.import crc16
000000r 2               		.import crc16_lp
000000r 2               		.import crc16_cl
000000r 2               
000000r 2               		.import inkey_clear
000000r 2               		.import ackEscape
000000r 2               		.import CheckESC
000000r 2               
000000r 2               		.import brkBadCommand
000000r 2               		.import brkInvalidArgument
000000r 2               
000000r 1               		.include "bltutil_romheader.inc"
000000r 2               
000000r 2               		.import	Copyright
000000r 2               		.import strCmdBLTurbo
000000r 2               		.import ServiceOut
000000r 2               		.import ServiceOutA0
000000r 2               
000000r 1               		.include "bltutil_jimstuff.inc"
000000r 2               		.import	CheckBlitterPresent
000000r 2               		.import	CheckPaulaPresent
000000r 2               		.import	CheckBlitterPresentBrk
000000r 2               		.import CheckEitherPresentBrk
000000r 2               		.import jimCheckEitherSelected
000000r 2               		.import	brkBlitterNotPresent
000000r 2               		.import	jimSetDEV_blitter
000000r 2               		.import	jimSetDEV_paula
000000r 2               		.import	jimSetDEV_either
000000r 2               		.import	jimSetDEV_A
000000r 2               		.import jimReleaseDev_err
000000r 2               		.import jimClaimDev
000000r 2               		.import jimPageWorkspace
000000r 2               		.import jimPageChipset
000000r 2               		.import jimPageVersion
000000r 2               		.import brkBlitterNotPresent
000000r 2               		.import	jimSetDEV_either_stack_old
000000r 2               		.import jimUnStackDev
000000r 2               		.import jimPageSamTbl
000000r 2               		.import jimPageSoundWorkspace
000000r 2               
000000r 1               
000000r 1               		.export	cmdSound
000000r 1               		.export sound_irq
000000r 1               		.export sound_OSWORD_SOUND
000000r 1               		.export cmdSoundSamLoad
000000r 1               		.export allocfreexy
000000r 1               		.export sound_boot
000000r 1               		.export cmdSoundSamMap
000000r 1               		.export cmdSoundSamClear
000000r 1               
000000r 1               
000000r 1               		.export pitch2period
000000r 1               		.export REMV_internal_SEV
000000r 1               		.export REMV_internal_CLV
000000r 1               		.import _LECA2
000000r 1               
000000r 1               
000000r 1               		.CODE
000000r 1               
000000r 1               ; TODO: call insv/remv direct rather than through OSBYTE for OSWORD_7
000000r 1               
000000r 1               
000000r 1               TIMER1VAL	:= 10000-2	; value for 100Hz
000000r 1               
000000r 1               		; TODO at boot look in sound's workspace and decide whether on / off / samples from there
000000r 1               		; - will require heap to persist over breaks - user option
000000r 1               
000000r 1  20 rr rr     sound_boot:	jsr	jimSetDEV_either		; either Blitter or Paula don't care which here
000003r 1  90 01        		bcc	@ok1
000005r 1  60           		rts
000006r 1  20 rr rr     @ok1:		jsr	jimPageSoundWorkspace
000009r 1  A9 00        		lda	#0
00000Br 1  8D 00 FD     		sta	JIM+SNDWKSP_SOUNDFLAGS
00000Er 1               
00000Er 1               		; clear sample table
00000Er 1  20 rr rr     		jsr	jimPageSamTbl
000011r 1  A2 00        		ldx	#0
000013r 1  A9 FF        		lda	#$FF
000015r 1  9D 00 FD     @l:		sta	JIM,X
000018r 1  E8           		inx
000019r 1  D0 FA        		bne	@l
00001Br 1  60           		rts
00001Cr 1               
00001Cr 1               
00001Cr 1               cmdSound:	; initialize user via timer 1 in free run, with interrupts
00001Cr 1               		; mask out interrupts to get an unknown interrupt service call
00001Cr 1  20 rr rr     		jsr	CheckEitherPresentBrk
00001Fr 1  20 rr rr     		jsr	jimPageSoundWorkspace
000022r 1               
000022r 1  AD 00 FD     		lda	JIM+SNDWKSP_SOUNDFLAGS
000025r 1  10 03        		bpl	@notalready
000027r 1  4C rr rr     		jmp	@already
00002Ar 1  A9 80        @notalready:	lda	#SCR_FLAG_SND_EN
00002Cr 1  8D 00 FD     		sta	JIM+SNDWKSP_SOUNDFLAGS
00002Fr 1               
00002Fr 1               
00002Fr 1               		; initialise hardware
00002Fr 1  20 rr rr     		jsr	jimPageChipset
000032r 1  A9 FF        		lda	#$FF
000034r 1  8D 8E FD     		sta	jim_DMAC_SND_MA_VOL
000037r 1  8D 8F FD     		sta	jim_DMAC_SND_SEL
00003Ar 1  AE 8F FD     		ldx	jim_DMAC_SND_SEL
00003Dr 1  E8           		inx
00003Er 1  8A           @sch1:		txa
00003Fr 1  48           		pha					; number of channels or 0 if read FF
000040r 1               
000040r 1               		; silence all channels
000040r 1  CA           @ls1:		dex
000041r 1  8E 8F FD     		stx	jim_DMAC_SND_SEL
000044r 1  A9 00        		lda	#0
000046r 1  8D 80 FD     		sta	jim_DMAC_SND_DATA
000049r 1  8D 89 FD     		sta	jim_DMAC_SND_VOL
00004Cr 1  8D 88 FD     		sta	jim_DMAC_SND_STATUS
00004Fr 1  E0 00        		cpx	#0
000051r 1  D0 ED        		bne	@ls1
000053r 1               
000053r 1               
000053r 1               
000053r 1  68           		pla
000054r 1  A2 rr        		ldx	#<str_SOUND_start
000056r 1  A0 rr        		ldy	#>str_SOUND_start
000058r 1  20 rr rr     		jsr	PrintMsgXYThenHexNyb
00005Br 1               
00005Br 1               		; initialise sound variables
00005Br 1  20 rr rr     		jsr	jimPageSoundWorkspace
00005Er 1               
00005Er 1               		; first set up buffers all with FF
00005Er 1  A9 FF        		lda	#$FF
000060r 1  A2 07        		ldx	#SND_NUM_CHANS-1
000062r 1  9D 20 FD     @l1:		sta	JIM+SNDWKSP_BUF_BUSY_0,X
000065r 1  CA           		dex
000066r 1  10 FA        		bpl	@l1
000068r 1  A9 14        		lda	#SND_BUF_LEN-1
00006Ar 1  A2 0F        		ldx	#(SND_NUM_CHANS*2)-1
00006Cr 1  9D 28 FD     @l2:		sta	JIM+SNDWKSP_BUF_OUT_0,X
00006Fr 1  CA           		dex
000070r 1  10 FA        		bpl	@l2
000072r 1               
000072r 1               		; zero all rest of SOUND vars
000072r 1  A2 88        		ldx	#SNDWKSP_VAR_END-SNDWKSP_VAR_START
000074r 1  A9 00        		lda	#0
000076r 1  9D 3F FD     @l3:		sta	JIM+SNDWKSP_VAR_START-1,X
000079r 1  CA           		dex
00007Ar 1  D0 FA        		bne	@l3
00007Cr 1               
00007Cr 1               
00007Cr 1               
00007Cr 1               		; capture INSV, REMV, CNPV
00007Cr 1               		; first a sanity check - if any of these are already extended vectors refuse to continue
00007Cr 1  A2 FF        		ldx	#$FF
00007Er 1  CD 0B 02     		cmp	BYTEV+1
000081r 1  F0 0F        		beq	@brkExtInUse
000083r 1  CD 2B 02     		cmp	INSV+1
000086r 1  F0 0A        		beq	@brkExtInUse
000088r 1  CD 2D 02     		cmp	REMV+1
00008Br 1  F0 05        		beq	@brkExtInUse
00008Dr 1  CD 2F 02     		cmp	CNPV+1
000090r 1  D0 3A        		bne	@ExtNotInUse
000092r 1  20 rr rr     @brkExtInUse:	M_ERROR
000095r 1  FF           		.byte	$FF
000096r 1  45 78 74 65  		.byte	"Extended vectors busy",0
00009Ar 1  6E 64 65 64  
00009Er 1  20 76 65 63  
0000ACr 1               
0000ACr 1  3F FF        @EXTVECS:	.word	EXTVEC_ENTER_INSV
0000AEr 1  42 FF        		.word	EXTVEC_ENTER_REMV
0000B0r 1  45 FF        		.word	EXTVEC_ENTER_CNPV
0000B2r 1  0F FF        		.word	EXTVEC_ENTER_BYTEV
0000B4r 1  rr rr        @MINE:		.word	SOUND_INSV
0000B6r 1  rr rr        		.word	SOUND_REMV
0000B8r 1  rr rr        		.word	SOUND_CNPV
0000BAr 1  rr rr        		.word	SOUND_BYTEV
0000BCr 1  2A 02        @NORMVECS:	.word	INSV
0000BEr 1  2C 02        		.word	REMV
0000C0r 1  2E 02        		.word	CNPV
0000C2r 1  0A 02        		.word	BYTEV
0000C4r 1  DE 0D        @EXTPTRS:	.word	EXT_INSV
0000C6r 1  E1 0D        		.word	EXT_REMV
0000C8r 1  E4 0D        		.word	EXT_CNPV
0000CAr 1  AE 0D        		.word	EXT_BYTEV
0000CCr 1               
0000CCr 1               @NUM_VECS:=	4
0000CCr 1               
0000CCr 1               
0000CCr 1               @ExtNotInUse:
0000CCr 1  08           		php
0000CDr 1  78           		sei
0000CEr 1               
0000CEr 1               		; save old vectors
0000CEr 1  A2 06        		ldx	#(@NUM_VECS-1)*2
0000D0r 1  A0 00        		ldy	#0
0000D2r 1               @vsl:
0000D2r 1               		; get address of normal vector into zp_tmp_ptr
0000D2r 1  BD rr rr     		lda	@NORMVECS,X
0000D5r 1  85 AC        		sta	zp_tmp_ptr
0000D7r 1  BD rr rr     		lda	@NORMVECS+1,X
0000DAr 1  85 AD        		sta	zp_tmp_ptr+1
0000DCr 1               
0000DCr 1               		; get old contents and put in our save pointer
0000DCr 1  B1 AC        		lda	(zp_tmp_ptr),Y
0000DEr 1  9D 02 FD     		sta	JIM+SNDWKSP_OLDINSV,X
0000E1r 1  C8           		iny
0000E2r 1  B1 AC        		lda	(zp_tmp_ptr),Y
0000E4r 1  9D 03 FD     		sta	JIM+SNDWKSP_OLDINSV+1,X
0000E7r 1               
0000E7r 1  BD rr rr     		lda	@EXTVECS+1,X			; and point to extended vectors
0000EAr 1  91 AC        		sta	(zp_tmp_ptr),Y
0000ECr 1  88           		dey
0000EDr 1  BD rr rr     		lda	@EXTVECS+0,X
0000F0r 1  91 AC        		sta	(zp_tmp_ptr),Y
0000F2r 1               
0000F2r 1               		;get address of extended vector pointer in zp_tmp_ptr
0000F2r 1  BD rr rr     		lda	@EXTPTRS,X
0000F5r 1  85 AC        		sta	zp_tmp_ptr
0000F7r 1  BD rr rr     		lda	@EXTPTRS+1,X
0000FAr 1  85 AD        		sta	zp_tmp_ptr+1
0000FCr 1               
0000FCr 1               		;point at our routine and rom
0000FCr 1  BD rr rr     		lda	@MINE,X
0000FFr 1  91 AC        		sta	(zp_tmp_ptr),Y
000101r 1  C8           		iny
000102r 1  BD rr rr     		lda	@MINE+1,X
000105r 1  91 AC        		sta	(zp_tmp_ptr),Y
000107r 1  C8           		iny
000108r 1  A5 F4        		lda	zp_mos_curROM
00010Ar 1  91 AC        		sta	(zp_tmp_ptr),Y
00010Cr 1               
00010Cr 1  88           		dey
00010Dr 1  88           		dey
00010Er 1  CA           		dex
00010Fr 1  CA           		dex
000110r 1  10 C0        		bpl	@vsl
000112r 1               
000112r 1               
000112r 1               		; set ACR for continuous T1 interrupts
000112r 1  AD 6B FE     		lda	sheila_USRVIA_acr
000115r 1  29 C0        		and	#VIA_ACR_T1_MASK
000117r 1  09 40        		ora	#VIA_ACR_T1_CONT
000119r 1  8D 6B FE     		sta	sheila_USRVIA_acr
00011Cr 1               
00011Cr 1               		; set T0 period
00011Cr 1  A9 0E        		lda	#<TIMER1VAL
00011Er 1  8D 66 FE     		sta	sheila_USRVIA_t1ll
000121r 1  A9 27        		lda	#>TIMER1VAL
000123r 1  8D 65 FE     		sta	sheila_USRVIA_t1ch
000126r 1               
000126r 1               		; clear pending IRQ
000126r 1  A9 C0        		lda	#VIA_IFR_BIT_T1+VIA_IFR_BIT_ANY
000128r 1  8D 6D FE     		sta	sheila_USRVIA_ifr
00012Br 1               		; enable interrupt
00012Br 1               
00012Br 1  8D 6E FE     		sta	sheila_USRVIA_ier
00012Er 1               
00012Er 1  28           		plp
00012Fr 1  60           @already:	rts
000130r 1               
000130r 1               
000130r 1  20 rr rr     brkSoundNotEn:	M_ERROR
000133r 1  FF           		.byte	$FF
000134r 1  53 6F 75 6E  		.byte	"Sound not enabled", 0
000138r 1  64 20 6E 6F  
00013Cr 1  74 20 65 6E  
000146r 1               
000146r 1  20 rr rr     brkEmpty:	M_ERROR
000149r 1  FF           		.byte	$FF
00014Ar 1  45 6D 70 74  		.byte	"Empty",0
00014Er 1  79 00        
000150r 1               
000150r 1  20 rr rr     brkTooBig:	M_ERROR
000153r 1  FF           		.byte	$FF
000154r 1  54 6F 6F 20  		.byte	"Too big",0
000158r 1  62 69 67 00  
00015Cr 1               
00015Cr 1               brkFileNotFound:
00015Cr 1  20 rr rr     		M_ERROR
00015Fr 1  D6           		.byte	ERR_FILE_NOT_FOUND
000160r 1  46 69 6C 65  		.byte	"File not found",0
000164r 1  20 6E 6F 74  
000168r 1  20 66 6F 75  
00016Fr 1               
00016Fr 1               SLSCR_FNPTR	:= 	SNDWKDP_SCRATCH8+0
00016Fr 1               SLSCR_REPL	:=	SNDWKDP_SCRATCH8+2
00016Fr 1               SLSCR_HANDLE	:=	SNDWKDP_SCRATCH8+4
00016Fr 1               SLSCR_NUM	:=	SNDWKDP_SCRATCH8+5
00016Fr 1               SLSCR_HASREPL	:=	SNDWKDP_SCRATCH8+6
00016Fr 1               SLSCR_NEGREP	:=	SNDWKDP_SCRATCH8+7
00016Fr 1               
00016Fr 1               
00016Fr 1               cmdSoundSamLoad:
00016Fr 1               		; load a simple into chip ram allocated from the heap
00016Fr 1  20 rr rr     		jsr	CheckEitherPresentBrk
000172r 1  20 rr rr     		jsr	jimPageSoundWorkspace		; page in scratch space bottom
000175r 1               
000175r 1  AD 00 FD     		lda	JIM+SNDWKSP_SOUNDFLAGS
000178r 1  10 B6        		bpl	brkSoundNotEn
00017Ar 1               
00017Ar 1               
00017Ar 1  20 rr rr     @bp:		jsr	SkipSpacesPTR
00017Dr 1  C9 0D        		cmp	#$D
00017Fr 1  D0 02        		bne	@s1
000181r 1  F0 1A        		beq	@badcmd				; no filename!
000183r 1  18           @s1:		clc
000184r 1  98           		tya
000185r 1  65 F2        		adc	zp_mos_txtptr
000187r 1  8D 10 FD     		sta	JIM+SLSCR_FNPTR			; store pointer to filename for OSFILE later
00018Ar 1  A5 F3        		lda	zp_mos_txtptr + 1
00018Cr 1  69 00        		adc	#0
00018Er 1  8D 11 FD     		sta	JIM+SLSCR_FNPTR+1		; store pointer to filename for OSFILE later
000191r 1  88           		dey
000192r 1  C8           @lp1:		iny
000193r 1  B1 F2        		lda	(zp_mos_txtptr),Y
000195r 1  C9 20        		cmp	#' '
000197r 1  90 04        		bcc	@badcmd
000199r 1  D0 F7        		bne	@lp1
00019Br 1  F0 03        		beq	@s3
00019Dr 1               
00019Dr 1  4C rr rr     @badcmd:	jmp	brkBadCommand
0001A0r 1               
0001A0r 1               @s3:
0001A0r 1               ;		don't terminate - it will kill a bbc basic program!
0001A0r 1               ;		lda	#$D
0001A0r 1               ;		sta	(zp_mos_txtptr),Y		; overwrite ' ' with $D to terminate filename
0001A0r 1  C8           		iny
0001A1r 1               
0001A1r 1  20 rr rr     		jsr	ParseHex
0001A4r 1  B0 F7        		bcs	@badcmd
0001A6r 1  A5 AC        		lda	zp_trans_acc
0001A8r 1  F0 F3        		beq	@badcmd
0001AAr 1  38           		sec
0001ABr 1  E9 01        		sbc	#1				; rebase to 0..31
0001ADr 1  48           		pha
0001AEr 1  29 E0        		and	#$E0
0001B0r 1  D0 EB        		bne	@badcmd
0001B2r 1  68           		pla
0001B3r 1  29 1F        		and	#$1F				; max samples
0001B5r 1  0A           		asl	A
0001B6r 1  0A           		asl	A
0001B7r 1  0A           		asl	A
0001B8r 1  8D 15 FD     		sta	JIM+SLSCR_NUM			; sam no * 8
0001BBr 1               
0001BBr 1  20 rr rr     		jsr	SkipSpacesPTR
0001BEr 1  C9 20        		cmp	#' '
0001C0r 1  08           		php
0001C1r 1               
0001C1r 1  20 rr rr     		jsr	zeroAcc
0001C4r 1  A9 00        		lda	#0
0001C6r 1  8D 16 FD     		sta	JIM+SLSCR_HASREPL
0001C9r 1  28           		plp
0001CAr 1  90 12        		bcc	@s2
0001CCr 1               
0001CCr 1  B1 F2        		lda	(zp_mos_txtptr),Y
0001CEr 1  49 2D        		eor	#'-'
0001D0r 1  8D 17 FD     		sta	JIM+SLSCR_NEGREP		; if negative repeat offset is subtracted from length
0001D3r 1  D0 01        		bne	@snom
0001D5r 1  C8           		iny
0001D6r 1  20 rr rr     @snom:		jsr	ParseHex
0001D9r 1  B0 C2        		bcs	@badcmd
0001DBr 1  CE 16 FD     		dec	JIM+SLSCR_HASREPL
0001DEr 1               @s2:		; store in scratch
0001DEr 1  AD 17 FD     		lda	JIM+SLSCR_NEGREP
0001E1r 1  A5 AC        		lda	zp_trans_acc
0001E3r 1  8D 12 FD     		sta	JIM+SLSCR_REPL
0001E6r 1  A5 AD        		lda	zp_trans_acc+1
0001E8r 1  8D 13 FD     		sta	JIM+SLSCR_REPL+1
0001EBr 1               
0001EBr 1               		; check to see if there's already a sample with this number and if there is free it
0001EBr 1  AD 15 FD     		lda	JIM+SLSCR_NUM
0001EEr 1  AA           		tax
0001EFr 1  48           		pha
0001F0r 1  20 rr rr     		jsr	jimPageSamTbl
0001F3r 1  BC 01 FD     		ldy	JIM+SAMTBLOFFS_BASE+1,X		; check for empty
0001F6r 1  30 11        		bmi	@nosamthere
0001F8r 1  BD 00 FD     		lda	JIM+SAMTBLOFFS_BASE,X
0001FBr 1  AA           		tax
0001FCr 1  A9 11        		lda	#OSWORD_OP_FREE
0001FEr 1  20 rr rr     		jsr	allocfreexy
000201r 1  68           		pla
000202r 1  48           		pha
000203r 1  AA           		tax
000204r 1  A9 FF        		lda	#$FF
000206r 1  9D 01 FD     		sta	JIM+SAMTBLOFFS_BASE+1,X		; mark empty in case we blob later
000209r 1  68           @nosamthere:	pla
00020Ar 1  20 rr rr     		jsr	jimPageSoundWorkspace
00020Dr 1               
00020Dr 1               		; attempt to open the file
00020Dr 1  AE 10 FD     		ldx	JIM+SLSCR_FNPTR
000210r 1  AC 11 FD     		ldy	JIM+SLSCR_FNPTR+1
000213r 1  A9 40        		lda	#OSFIND_OPENIN
000215r 1  20 CE FF     		jsr	OSFIND
000218r 1  09 00        		ora	#$00
00021Ar 1  D0 03        		bne	@s5
00021Cr 1  4C rr rr     @brkfilenotfound:jmp	brkFileNotFound
00021Fr 1               @s5:
00021Fr 1               
00021Fr 1  8D 14 FD     		sta	JIM+SLSCR_HANDLE
000222r 1               
000222r 1               		; get file extent
000222r 1  A8           		tay
000223r 1  A9 02        		lda	#OSARGS_EXT
000225r 1  A2 AC        		ldx	#zp_trans_acc
000227r 1  20 DA FF     		jsr	OSARGS
00022Ar 1               
00022Ar 1               		; zp_trans_acc should now contain file size
00022Ar 1               		; check for 0
00022Ar 1  20 rr rr     		jsr	isAcc0
00022Dr 1  D0 03        		bne	@skemp
00022Fr 1  4C rr rr     @brkempty:	jmp	brkEmpty
000232r 1               @skemp:
000232r 1               		; store length and repl
000232r 1  AE 15 FD     		ldx	JIM+SLSCR_NUM
000235r 1               
000235r 1               		; subtract REPL from LEN if - was specified
000235r 1  AD 17 FD     		lda	JIM+SLSCR_NEGREP
000238r 1  D0 16        		bne	@snomin
00023Ar 1  2C 16 FD     		bit	JIM+SLSCR_HASREPL
00023Dr 1  10 11        		bpl	@snomin
00023Fr 1  38           		sec
000240r 1  A5 AC        		lda	zp_trans_acc
000242r 1  ED 12 FD     		sbc	JIM+SLSCR_REPL
000245r 1  8D 12 FD     		sta	JIM+SLSCR_REPL
000248r 1  A5 AD        		lda	zp_trans_acc+1
00024Ar 1  ED 13 FD     		sbc	JIM+SLSCR_REPL+1
00024Dr 1  8D 13 FD     		sta	JIM+SLSCR_REPL+1
000250r 1               
000250r 1               
000250r 1  AD 12 FD     @snomin:	lda	JIM+SLSCR_REPL
000253r 1  AC 13 FD     		ldy	JIM+SLSCR_REPL+1
000256r 1  2E 16 FD     		rol	JIM+SLSCR_HASREPL
000259r 1               		; store sample base in sample table
000259r 1  20 rr rr     		jsr	jimPageSamTbl
00025Cr 1  7E 07 FD     		ror	JIM+SAMTBLOFFS_FLAGS,X
00025Fr 1  9D 04 FD     		sta	JIM+SAMTBLOFFS_REPL,X
000262r 1  98           		tya
000263r 1  9D 05 FD     		sta	JIM+SAMTBLOFFS_REPL+1,X
000266r 1  A5 AC        		lda	zp_trans_acc
000268r 1  9D 02 FD     		sta	JIM+SAMTBLOFFS_LEN,X
00026Br 1  A5 AD        		lda	zp_trans_acc+1
00026Dr 1  9D 03 FD     		sta	JIM+SAMTBLOFFS_LEN+1,X
000270r 1  20 rr rr     		jsr	jimPageSoundWorkspace
000273r 1               
000273r 1               		; round to a number of pages
000273r 1  A5 AC        		lda	zp_trans_acc
000275r 1  F0 0A        		beq	@sround
000277r 1  E6 AD        		inc	zp_trans_acc+1
000279r 1  D0 06        		bne	@sround
00027Br 1  E6 AE        		inc	zp_trans_acc+2
00027Dr 1  D0 02        		bne	@sround
00027Fr 1  E6 AF        		inc	zp_trans_acc+3
000281r 1               @sround:
000281r 1               		; check for huge file
000281r 1  A5 AF        		lda	zp_trans_acc+3
000283r 1  05 AE        		ora	zp_trans_acc+2
000285r 1  D0 7D        		bne	@brktoobig
000287r 1               
000287r 1               		; stash file handle for later
000287r 1  AD 14 FD     		lda	JIM+SLSCR_HANDLE
00028Ar 1  85 AF        		sta	zp_trans_acc+3
00028Cr 1               
00028Cr 1               		; alloc on heap
00028Cr 1               		; make room on stack for OSWORD
00028Cr 1               
00028Cr 1  A9 10        		lda	#OSWORD_OP_ALLOC
00028Er 1  A6 AD        		ldx	zp_trans_acc+1
000290r 1  A0 00        		ldy	#0
000292r 1  20 rr rr     		jsr	allocfreexy
000295r 1  E8           		inx
000296r 1  D0 04        		bne	@bb2
000298r 1  C8           		iny
000299r 1  F0 69        		beq	@brktoobig
00029Br 1  88           		dey
00029Cr 1  CA           @bb2:		dex
00029Dr 1  8A           		txa
00029Er 1               
00029Er 1  AE 15 FD     		ldx	JIM+SLSCR_NUM
0002A1r 1               		; store sample base in sample table
0002A1r 1  20 rr rr     		jsr	jimPageSamTbl
0002A4r 1  9D 00 FD     		sta	JIM+SAMTBLOFFS_BASE,X
0002A7r 1  48           		pha
0002A8r 1  98           		tya
0002A9r 1  9D 01 FD     		sta	JIM+SAMTBLOFFS_BASE+1,X
0002ACr 1  68           		pla
0002ADr 1               
0002ADr 1               		; now load the file
0002ADr 1  8C FD FC     		sty	fred_JIM_PAGE_HI
0002B0r 1  8D FE FC     		sta	fred_JIM_PAGE_LO
0002B3r 1               ;;		; TODO: use OSGBPB if proves too slow but where to put buffer? Wait for Hazel?
0002B3r 1               ;;		ldx	#0
0002B3r 1               ;;		ldy	zp_trans_acc+3
0002B3r 1               ;;@here:
0002B3r 1               ;;@loadlp:	jsr	OSBGET
0002B3r 1               ;;		bcs	@eof
0002B3r 1               ;;		sta	JIM,X
0002B3r 1               ;;		inx
0002B3r 1               ;;		bne	@loadlp
0002B3r 1               
0002B3r 1               
0002B3r 1               @loadlp:	; make GBPB block on stack
0002B3r 1  A2 0C        		ldx	#12
0002B5r 1  BD rr rr     @mkblklp:	lda	@loadgbpbblock-1,X
0002B8r 1  48           		pha
0002B9r 1  CA           		dex
0002BAr 1  D0 F9        		bne	@mkblklp
0002BCr 1  A5 AF        		lda	zp_trans_acc+3
0002BEr 1  48           		pha				; handle
0002BFr 1  BA           		tsx
0002C0r 1  E8           		inx
0002C1r 1  A0 01        		ldy	#1			; point at block on stack
0002C3r 1  A9 04        		lda	#OSGBPB_READ_NOPTR
0002C5r 1  20 D1 FF     		jsr	OSGBPB
0002C8r 1               
0002C8r 1               		; unstack and get number of bytes xfered
0002C8r 1  BA           		tsx
0002C9r 1  BD 06 01     		lda	$106,X
0002CCr 1  1D 07 01     		ora	$107,X
0002CFr 1  9D 0D 01     		sta	$10D,X
0002D2r 1  8A           		txa
0002D3r 1  18           		clc
0002D4r 1  69 0C        		adc	#12
0002D6r 1  AA           		tax
0002D7r 1  9A           		txs
0002D8r 1               
0002D8r 1  68           		pla
0002D9r 1  D0 0F        		bne	@eof
0002DBr 1               
0002DBr 1  A9 2E        		lda	#'.'
0002DDr 1  20 EE FF     		jsr	OSWRCH
0002E0r 1  EE FE FC     		inc	fred_JIM_PAGE_LO
0002E3r 1  D0 CE        		bne	@loadlp
0002E5r 1  EE FD FC     		inc	fred_JIM_PAGE_HI
0002E8r 1  D0 C9        		bne	@loadlp
0002EAr 1               
0002EAr 1  20 rr rr     @eof:		jsr	@closef
0002EDr 1  20 E7 FF     		jsr	OSNEWL
0002F0r 1  60           		rts
0002F1r 1               
0002F1r 1  00 FD FF FF  @loadgbpbblock:	.dword	$FFFFFD00	; JIM
0002F5r 1  00 01 00 00  		.dword	$00000100	; count
0002F9r 1               
0002F9r 1               
0002F9r 1  20 rr rr     @closef:	jsr	jimPageSoundWorkspace
0002FCr 1  AC 14 FD     		ldy	JIM+SLSCR_HANDLE
0002FFr 1  A9 00        		lda	#OSFIND_CLOSE
000301r 1  4C CE FF     		jmp	OSFIND
000304r 1               
000304r 1  20 rr rr     @brktoobig:	jsr	@closef
000307r 1  4C rr rr     		jmp	brkTooBig
00030Ar 1               
00030Ar 1               		; on entry A = &10 or &11 for Alloc/Free, XY contains length or base
00030Ar 1               		; returns in X/Y
00030Ar 1               allocfreexy:
00030Ar 1  48           		pha
00030Br 1  98           		tya
00030Cr 1  48           		pha
00030Dr 1  8A           		txa
00030Er 1  48           		pha
00030Fr 1               
00030Fr 1               		; make room on stack for OSWORD
00030Fr 1               
00030Fr 1  A2 05        		ldx	#5
000311r 1  8A           		txa
000312r 1  20 rr rr     		jsr	StackAllocX
000315r 1               
000315r 1  9D 00 01     		sta	$100,X			; # bytes in
000318r 1  9D 01 01     		sta	$101,X			; # bytes out
00031Br 1  BD 05 01     		lda	$105,X			; X on stack above our alloc
00031Er 1  9D 03 01     		sta	$103,X
000321r 1  BD 06 01     		lda	$106,X			; Y on stack above our alloc
000324r 1  9D 04 01     		sta	$104,X
000327r 1  BD 07 01     		lda	$107,X			; A on stack above our alloc
00032Ar 1  9D 02 01     		sta	$102,X
00032Dr 1  8A           		txa
00032Er 1  48           		pha				; save X we'll need it back
00032Fr 1  A0 01        		ldy	#$01			; it's on the stack
000331r 1  A9 99        		lda	#OSWORD_BLTUTIL
000333r 1  20 F1 FF     		jsr	OSWORD
000336r 1  68           		pla
000337r 1  AA           		tax
000338r 1  BD 04 01     		lda	$104,X
00033Br 1  9D 06 01     		sta	$106,X
00033Er 1  BD 03 01     		lda	$103,X
000341r 1  9D 05 01     		sta	$105,X
000344r 1  20 rr rr     		jsr	StackFree
000347r 1  68           		pla
000348r 1  AA           		tax
000349r 1  68           		pla
00034Ar 1  A8           		tay
00034Br 1  68           		pla
00034Cr 1  60           		rts
00034Dr 1               
00034Dr 1               
00034Dr 1               
00034Dr 1               ; Process sound osword
00034Dr 1               ; Channel parameter is of the normal MOS form, except with &4000 added
00034Dr 1               ; Volume high byte contains a sample #
00034Dr 1               ; TODO: there's some juggling of X to convert between buffer number and internal number
00034Dr 1               ;       move buffers so that they're all > &14 from start of JIM to allow coded in -$14 without
00034Dr 1               ;	page boundary crossing nonsense
00034Dr 1               
00034Dr 1               OSWORD_SOUND_BASE := $40
00034Dr 1               OSWORD_SOUND_MASK := $E0
00034Dr 1               
00034Dr 1               
00034Dr 1  B1 F0        _LE8C9:		lda	(zp_mos_OSBW_X),Y		; get byte
00034Fr 1  29 1F        		and	#$1F				; mask out $40 for paula select
000351r 1  C9 10        		cmp	#$10				; is it greater than 15, if so set carry
000353r 1  29 07        		and	#$07				; and 7 to clear bits 3-7		(8 channels!)
000355r 1  C8           		iny					; increment Y
000356r 1  60           		rts					; and exit
000357r 1               
000357r 1               
000357r 1               sound_OSWORD_SOUND:
000357r 1  A0 01        		ldy	#1
000359r 1  B1 F0        		lda	(zp_mos_OSBW_X),Y	; get channel #hi byte check for our allocation
00035Br 1  29 E0        		and	#OSWORD_SOUND_MASK
00035Dr 1  C9 40        		cmp	#OSWORD_SOUND_BASE
00035Fr 1  F0 03        		beq	@sk1
000361r 1  4C rr rr     @out:		jmp	ServiceOut
000364r 1               @sk1:
000364r 1  20 rr rr     		jsr	jimSetDEV_either
000367r 1  B0 F8        		bcs	@out
000369r 1               		; check BLSOUND is enabled
000369r 1  20 rr rr     		jsr	jimPageSoundWorkspace
00036Cr 1  2C 00 FD     		bit	JIM+SNDWKSP_SOUNDFLAGS
00036Fr 1  10 F0        		bpl	@out
000371r 1               
000371r 1  88           		dey					; Point back to channel low byte
000372r 1  20 rr rr     		jsr	_LE8C9				; Get Channel 0-7, and Cy if >=&10 for Flush (note: 8chan)
000375r 1  08           		php
000376r 1  18           		clc
000377r 1  69 14        		adc	#SND_BUFFER_NUMBER_0		; Convert to buffer number $14-1C
000379r 1  AA           		tax
00037Ar 1  28           		plp					; TODO: not sure why this is needed interrupts somewhere?
00037Br 1  90 05        		bcc	_BE848				; If not Flush, skip past
00037Dr 1  20 rr rr     		jsr	_LE1AE				; Flush buffer
000380r 1  A0 01        		ldy	#$01				; Point back to channel high byte
000382r 1               
000382r 1  20 rr rr     _BE848:		jsr	_LE8C9				; Get Sync 0-7, and Cy if >=&10 for Hold (note: 8channels)
000385r 1  85 FA        		sta	zp_mos_OS_wksp2			; Save Sync in &FA
000387r 1  08           		php					; Stack flags
000388r 1  A0 06        		ldy	#$06
00038Ar 1  B1 F0        		lda	(zp_mos_OSBW_X),Y		; Get Duration byte
00038Cr 1  48           		pha					; and stack it
00038Dr 1  A0 04        		ldy	#$04
00038Fr 1  B1 F0        		lda	(zp_mos_OSBW_X),Y		; Get pitch byte
000391r 1  48           		pha					; and stack it
000392r 1  A0 02        		ldy	#$02				;
000394r 1  B1 F0        		lda	(zp_mos_OSBW_X),Y		; Get amplitude/envelope byte
000396r 1  2A           		rol					; Move Hold into bit 0
000397r 1               
000397r 1               		; AAAA AAAH
000397r 1               
000397r 1  38           		sec					; set carry
000398r 1  E9 02        		sbc	#$02				; subract 2
00039Ar 1               		; aaaa aaaH
00039Ar 1  0A           		asl					; multiply by 8
00039Br 1  0A           		asl
00039Cr 1  0A           		asl					; DB: note for 8 channels the amplitude is shifted left
00039Dr 1               							; 1 more place so the env/not env flag is in carry
00039Dr 1               							; which will live in bit 7 of the sample number (extra)
00039Dr 1               							; byte
00039Dr 1               		; aaaa H---				;
00039Dr 1  05 FA        		ora	zp_mos_OS_wksp2			; add S byte (0-7)
00039Fr 1               		; aaaa HSSS
00039Fr 1               
00039Fr 1  85 FA        		sta	zp_mos_OS_wksp2			; DB: save the amp/env/hold/sync byte
0003A1r 1  08           		php					; stack envelope flag
0003A2r 1               
0003A2r 1               		; DB: new extra byte for sample # and envelope flag
0003A2r 1  C8           		iny
0003A3r 1  B1 F0        		lda	(zp_mos_OSBW_X),Y		; Get amplitude/high byte
0003A5r 1               		; to maintain compatibility if the high byte is 0 or $FF then "default" sample #1
0003A5r 1  F0 04        		beq	@defsam
0003A7r 1  C9 FF        		cmp	#$FF
0003A9r 1  D0 07        		bne	@notdefsam
0003ABr 1  BD AC FD     @defsam:	lda	JIM+SNDWKSP_DEF_SAM-SND_BUFFER_NUMBER_0,X
0003AEr 1  30 05        		bmi	@sam
0003B0r 1  A9 01        		lda	#$01
0003B2r 1  38           @notdefsam:	sec
0003B3r 1  E9 01        		sbc	#1				; convert to 0 based number
0003B5r 1  29 1F        @sam:		and	#31
0003B7r 1  0A           		asl	A
0003B8r 1  28           		plp
0003B9r 1  6A           		ror	A				; get envelope flag into top bit
0003BAr 1  48           @notamp:	pha
0003BBr 1  A5 FA        		lda	zp_mos_OS_wksp2
0003BDr 1               
0003BDr 1               
0003BDr 1  20 rr rr     		jsr	_BUFFER_SAVE			; Insert into buffer
0003C0r 1  90 07        		bcc	_BE887				; Buffer not full, jump to insert the rest
0003C2r 1  68           _BE869:		pla					; DB: extra pull
0003C3r 1  68           		pla					; Drop stacked pitch
0003C4r 1  68           		pla					; Drop stacked duration
0003C5r 1  28           		plp					; Restore flags
0003C6r 1  4C rr rr     		jmp	ServiceOutA0
0003C9r 1               
0003C9r 1  38           _BE887:		sec					; Set carry
0003CAr 1  7E 2C FD     		ror	JIM+SNDWKSP_QUEUE_OCC-SND_BUFFER_NUMBER_0,X
0003CDr 1               							; Set bit 7 of channel flags to indicate it's active
0003CDr 1               
0003CDr 1  68           _BE8A4:		pla					; sample # and env flag
0003CEr 1  20 rr rr     		jsr	_INSV				; Insert
0003D1r 1  68           		pla					; Get word number high byte or pitch back
0003D2r 1  20 rr rr     		jsr	_INSV				; Insert
0003D5r 1  68           		pla					; Get word number low byte or duration back
0003D6r 1  20 rr rr     		jsr	_INSV				; Insert
0003D9r 1  28           		plp					; Restore flags
0003DAr 1  4C rr rr     		jmp	ServiceOutA0			; and return
0003DDr 1               
0003DDr 1               
0003DDr 1               
0003DDr 1  6C 2A 02     _INSV:		jmp	(INSV)
0003E0r 1               
0003E0r 1               
0003E0r 1               		; flush sound buffer X
0003E0r 1  48           _LE1AE:		pha					; save A
0003E1r 1  08           		php					; save flags
0003E2r 1  78           		sei					; set interrupts
0003E3r 1               
0003E3r 1  38           _BE1BB:		sec					; set carry
0003E4r 1  7E 0C FD     		ror	JIM+SNDWKSP_BUF_BUSY_0-SND_BUFFER_NUMBER_0,X
0003E7r 1               							; rotate buffer flag to show buffer empty
0003E7r 1  2C rr rr     		bit	_BD9B7				; set V
0003EAr 1  20 rr rr     _BE73E:		jsr	__CNPV				; CNPV with V set to purge buffer
0003EDr 1  28           		plp					; restore flags
0003EEr 1  68           		pla					; restore A
0003EFr 1  60           		rts
0003F0r 1               
0003F0r 1  6C 2E 02     __CNPV:		jmp	(CNPV)
0003F3r 1               
0003F3r 1  FF           _BD9B7:		.byte 	$FF
0003F4r 1               _LE73B:
0003F4r 1               
0003F4r 1               ;********** enter byte in buffer, wait and flash lights if full **********
0003F4r 1               
0003F4r 1  78           _BUFFER_SAVE:		sei					; prevent interrupts
0003F5r 1  20 rr rr     			jsr	_INSV				; enter a byte in buffer X
0003F8r 1  90 0F        			bcc	@_buffer_save_done		; if successful exit
0003FAr 1  20 rr rr     			jsr	@SET_LEDS_TEST_ESCAPE		; else switch on both keyboard lights
0003FDr 1  08           			php					; push p
0003FEr 1  48           			pha					; push A
0003FFr 1  20 rr rr     			jsr	_SET_LEDS			; switch off unselected LEDs
000402r 1  68           			pla					; get back A
000403r 1  28           			plp					; and flags
000404r 1  30 03        			bmi	@_buffer_save_done		; if return is -ve Escape pressed so exit
000406r 1  58           			cli					; else allow interrupts
000407r 1  B0 EB        			bcs	_BUFFER_SAVE			; if byte didn't enter buffer go and try it again
000409r 1  60           @_buffer_save_done:	rts					; then return
00040Ar 1               
00040Ar 1               @SET_LEDS_TEST_ESCAPE:	;;bcc	_BE9F5				; if carry clear
00040Ar 1  A0 07        			ldy	#$07				; switch on shift lock light
00040Cr 1  8C 40 FE     			sty	sheila_SYSVIA_orb		;
00040Fr 1  88           			dey					; Y=6
000410r 1  8C 40 FE     			sty	sheila_SYSVIA_orb		; switch on Caps lock light
000413r 1  24 FF        			bit	zp_mos_ESC_flag			; set minus flag if bit 7 of &00FF is set indicating
000415r 1  60           			rts					; that ESCAPE condition exists, then return
000416r 1               
000416r 1               ;**********: Turn on Keyboard indicators *******************************
000416r 1               _SET_LEDS:		;;php					; save flags
000416r 1  AD 5A 02     			lda	sysvar_KEYB_STATUS		; read keyboard status;
000419r 1               								; Bit 7	 =1 shift enabled
000419r 1               								; Bit 6	 =1 control pressed
000419r 1               								; bit 5	 =0 shift lock
000419r 1               								; Bit 4	 =0 Caps lock
000419r 1               								; Bit 3	 =1 shift pressed
000419r 1  4A           			lsr					; shift Caps bit into bit 3
00041Ar 1  29 18        			and	#$18				; mask out all but 4 and 3
00041Cr 1  09 06        			ora	#$06				; returns 6 if caps lock OFF &E if on
00041Er 1  8D 40 FE     			sta	sheila_SYSVIA_orb		; turn on or off caps light if required
000421r 1  4A           			lsr					; bring shift bit into bit 3
000422r 1  09 07        			ora	#$07				;
000424r 1  8D 40 FE     			sta	sheila_SYSVIA_orb		; turn on or off shift	lock light
000427r 1  20 rr rr     			jsr	_LF12E				; set keyboard counter
00042Ar 1               			;;pla					; get back flags
00042Ar 1  60           			rts					; return
00042Br 1               
00042Br 1               ;*************Enable counter scan of keyboard columns *******************
00042Br 1               				; called from &EEFD, &F129
00042Br 1               
00042Br 1  A9 0B        _LF12E:			lda	#$0b				; select auto scan of keyboard
00042Dr 1  8D 40 FE     			sta	sheila_SYSVIA_orb		; tell VIA
000430r 1  8A           			txa					; Get A into X
000431r 1  60           			rts					; and return
000432r 1               
000432r 1               
000432r 1               
000432r 1               
000432r 1               
000432r 1               ; sound clock speed 3.547672
000432r 1               
000432r 1               
000432r 1               ; This code adapted from MOS disassembly found at https://github.com/raybellis/mos120
000432r 1               
000432r 1               ; trashes Y, requires sound workspace to be paged in
000432r 1               
000432r 1               ;	oct = P / 48		; octave number
000432r 1               ;	sem = (P/4) % 12	; semitone within octave
000432r 1               ;	eig = P % 		; eigth within semitone
000432r 1               ;
000432r 1               ;	LO = pitchtable1[sem]
000432r 1               ;	HI = pitchtable2[sem] % 4
000432r 1               ;	X = pitchtable2[sem] >> 4
000432r 1               ;	WHILE eig > 0
000432r 1               ;		[HI,LO] -= X
000432r 1               ;		eig--
000432r 1               ;	WEND
000432r 1               ;	WHILE oct > 0
000432r 1               ;		[HI,LO] /= 2
000432r 1               ;		oct--
000432r 1               ;	WEND
000432r 1               ;
000432r 1               
000432r 1               
000432r 1               pitch2period:
000432r 1  48           _BED16:			pha					;
000433r 1  29 03        			and	#$03				;
000435r 1  8D BC FD     			sta	JIM+SNDWKSP_WS_0		; lose eigth tone surplus
000438r 1  A9 00        			lda	#$00				;
00043Ar 1  8D BD FD     			sta	JIM+SNDWKSP_FREQ_LO		;
00043Dr 1  68           			pla					; get back A
00043Er 1  4A           			lsr					; divide by 48
00043Fr 1  4A           			lsr					;
000440r 1  C9 0C        _BED24:			cmp	#$0c				;
000442r 1  90 07        			bcc	_BED2F				;
000444r 1  EE BD FD     			inc	JIM+SNDWKSP_FREQ_LO		; store result
000447r 1  E9 0C        			sbc	#$0c				; with remainder in A
000449r 1  D0 F5        			bne	_BED24				;
00044Br 1               								; at this point 83D defines the Octave
00044Br 1               								; A the semitone within the octave
00044Br 1  A8           _BED2F:			tay					; Y=A
00044Cr 1  AD BD FD     			lda	JIM+SNDWKSP_FREQ_LO		; get octave number into A
00044Fr 1  48           			pha					; push it
000450r 1  B9 rr rr     			lda	_SOUND_PITCH_TABLE_1,Y		; get byte from look up table
000453r 1  8D BD FD     			sta	JIM+SNDWKSP_FREQ_LO		; store it
000456r 1  B9 rr rr     			lda	_SOUND_PITCH_TABLE_2,Y		; get byte from second table
000459r 1  48           			pha					; push it
00045Ar 1  29 07        			and	#$07				; keep two LS bits only
00045Cr 1  8D BE FD     			sta	JIM+SNDWKSP_FREQ_HI		; save them
00045Fr 1  68           			pla					; pull second table byte
000460r 1  4A           			lsr					; push hi nybble into lo nybble
000461r 1  4A           			lsr					;
000462r 1  4A           			lsr					;
000463r 1  8D BF FD     			sta	JIM+SNDWKSP_WS_3		; store it
000466r 1  AD BD FD     			lda	JIM+SNDWKSP_FREQ_LO		; lo byte from table lookup in TABLE_1
000469r 1  AC BC FD     			ldy	JIM+SNDWKSP_WS_0		; adjust for surplus eighth tones
00046Cr 1  F0 0C        			beq	_BED5F				;
00046Er 1  38           _BED53:			sec					;
00046Fr 1  ED BF FD     			sbc	JIM+SNDWKSP_WS_3		;
000472r 1  B0 03        			bcs	_BED5C				;
000474r 1  CE BE FD     			dec	JIM+SNDWKSP_FREQ_HI		;
000477r 1  88           _BED5C:			dey					;
000478r 1  D0 F4        			bne	_BED53				;
00047Ar 1  8D BD FD     _BED5F:			sta	JIM+SNDWKSP_FREQ_LO		;
00047Dr 1  68           			pla					;
00047Er 1  A8           			tay					;
00047Fr 1  F0 09        			beq	_BED6F				;
000481r 1  4E BE FD     _BED66:			lsr	JIM+SNDWKSP_FREQ_HI		;
000484r 1  6E BD FD     			ror	JIM+SNDWKSP_FREQ_LO		;
000487r 1  88           			dey					;
000488r 1  D0 F7        			bne	_BED66				;
00048Ar 1               _BED6F:
00048Ar 1               	; TODO: the following is for the channel de-tune - not sure I want that
00048Ar 1               ;			lda	JIM+SNDWKSP_FREQ_LO		;
00048Ar 1               ;			clc					;
00048Ar 1               ;			adc	_LC43D,X			;
00048Ar 1               ;			sta	JIM+SNDWKSP_FREQ_LO		;
00048Ar 1               ;			bcc	_BED7E				;
00048Ar 1               ;			inc	JIM+SNDWKSP_FREQ_HI		;
00048Ar 1  60           			rts
00048Br 1               
00048Br 1               
00048Br 1               
00048Br 1               ; Generated by pitchtable.pl, assumptions:
00048Br 1               ; PAULA_FREQ=3547672
00048Br 1               ; SAMPLE_LEN=32
00048Br 1               ; SAMPLE_RATE=8372 (middle C) [8377.02951593861]
00048Br 1               ; note these tables are packed differently to the MOS with 3 bits for HI and 5 for 8th adjust
00048Br 1               
00048Br 1  81           _SOUND_PITCH_TABLE_1:                           .byte $81
00048Cr 1  4F                                   .byte $4F
00048Dr 1  1F                                   .byte $1F
00048Er 1  F3                                   .byte $F3
00048Fr 1  C8                                   .byte $C8
000490r 1  A0                                   .byte $A0
000491r 1  7A                                   .byte $7A
000492r 1  57                                   .byte $57
000493r 1  35                                   .byte $35
000494r 1  15                                   .byte $15
000495r 1  F7                                   .byte $F7
000496r 1  DB                                   .byte $DB
000497r 1  63           _SOUND_PITCH_TABLE_2:                           .byte $63
000498r 1  63                                   .byte $63
000499r 1  5B                                   .byte $5B
00049Ar 1  52                                   .byte $52
00049Br 1  52                                   .byte $52
00049Cr 1  4A                                   .byte $4A
00049Dr 1  42                                   .byte $42
00049Er 1  42                                   .byte $42
00049Fr 1  42                                   .byte $42
0004A0r 1  3A                                   .byte $3A
0004A1r 1  39                                   .byte $39
0004A2r 1  31                                   .byte $31
0004A3r 1               
0004A3r 1               ; TODO: uses $100 - not sure this is safe?
0004A3r 1               
0004A3r 1               SOUND_INSV:
0004A3r 1  20 rr rr     		jsr	jimSetDEV_either_stack_old
0004A6r 1  08           		php
0004A7r 1  48           		pha
0004A8r 1  20 rr rr     		jsr	jimPageSoundWorkspace
0004ABr 1  AD 02 FD     		lda	JIM+SNDWKSP_OLDINSV
0004AEr 1  8D 00 01     		sta	$100
0004B1r 1  AD 03 FD     		lda	JIM+SNDWKSP_OLDINSV+1
0004B4r 1  8D 01 01     		sta	$101
0004B7r 1  68           		pla
0004B8r 1  28           		plp
0004B9r 1               
0004B9r 1               ;*************************************************************************
0004B9r 1               ;*									 *
0004B9r 1               ;*	 INSBV insert character in buffer vector default entry point	 *
0004B9r 1               ;*									 *
0004B9r 1               ;*************************************************************************
0004B9r 1               ;on entry X is buffer number, A is character to be written
0004B9r 1               ; adapted from MOS, need to avoid page boundary crossing indexed reads/writes as that would tickle page FC
0004B9r 1               ; instead indexes are all positive instead of in the MOS the indexes increase toward 0
0004B9r 1               
0004B9r 1  08           			php					; save flags
0004BAr 1  78           			sei					; bar interrupts
0004BBr 1  48           			pha					; save A
0004BCr 1  8A           			txa
0004BDr 1  48           			pha					; DB:save X
0004BEr 1  38           			sec
0004BFr 1  E9 14        			sbc	#SND_BUFFER_NUMBER_0		; get buffer base number and subtract
0004C1r 1  AA           			tax
0004C2r 1  C9 08        			cmp	#SND_NUM_CHANS
0004C4r 1  B0 2B        			bcs	@exitpasson
0004C6r 1               @here:
0004C6r 1  BC 30 FD     			ldy	JIM+SNDWKSP_BUF_IN_0,X		; get buffer input pointer
0004C9r 1  C8           			iny					; increment Y
0004CAr 1  C0 15        			cpy	#SND_BUF_LEN
0004CCr 1  D0 02        			bne	@_BE4BF
0004CEr 1  A0 00        			ldy	#0				; get default buffer start
0004D0r 1  98           @_BE4BF:		tya					; put it in A
0004D1r 1  DD 28 FD     			cmp	JIM+SNDWKSP_BUF_OUT_0,X		; compare it with input pointer
0004D4r 1  F0 14        			beq	@_BE4D4				; if equal buffer is full so E4D4
0004D6r 1  BC 30 FD     			ldy	JIM+SNDWKSP_BUF_IN_0,X		; else get buffer end in Y
0004D9r 1  9D 30 FD     			sta	JIM+SNDWKSP_BUF_IN_0,X		; and set it from A
0004DCr 1  20 rr rr     			jsr	_GET_BUFFER_ADDRESS		; and point &FA/B at it
0004DFr 1  68           			pla
0004E0r 1  AA           			tax					; get back un mangled X
0004E1r 1  68           			pla					; get back byte
0004E2r 1  91 FA        			sta	(zp_mos_OS_wksp2),Y		; store it in buffer
0004E4r 1  28           			plp					; pull flags
0004E5r 1  18           			clc					; clear carry for success
0004E6r 1  20 rr rr     @unstackrts:		jsr	jimUnStackDev			; unstack device and exit
0004E9r 1  60           			rts					; DB: NOTE do not remove this the jimUnStackDev does funky shit with the stack
0004EAr 1               
0004EAr 1               @_BE4D4:
0004EAr 1               
0004EAr 1               ;***** return with carry set *********************************************
0004EAr 1               @exit_sec:
0004EAr 1  68           			pla
0004EBr 1  AA           			tax					; DB: restore X
0004ECr 1  68           			pla					; restore A
0004EDr 1  28           @_BE4E0:		plp					; restore flags
0004EEr 1  38           			sec					; set carry
0004EFr 1  B0 F5        			bcs	@unstackrts
0004F1r 1               
0004F1r 1  68           @exitpasson:		pla
0004F2r 1  AA           			tax
0004F3r 1  68           			pla
0004F4r 1  28           			plp
0004F5r 1  20 rr rr     			jsr	jimUnStackDev
0004F8r 1  6C 00 01     			jmp	($100)
0004FBr 1               
0004FBr 1               
0004FBr 1               
0004FBr 1               ;*******: get nominal buffer addresses in &FA/B **************************
0004FBr 1               
0004FBr 1               ; X is 0..7
0004FBr 1               
0004FBr 1  08           _GET_BUFFER_ADDRESS:	php
0004FCr 1  A9 84        			lda	#<PAGE_SOUNDBUFFERS
0004FEr 1  8D FE FC     			sta	fred_JIM_PAGE_LO
000501r 1  A9 00        			lda	#>PAGE_SOUNDBUFFERS
000503r 1  8D FD FC     			sta	fred_JIM_PAGE_HI
000506r 1  8A           			txa					; buffer address is JIM+20*X
000507r 1               			; need to multiply by 21
000507r 1  18           			clc
000508r 1  85 FB        			sta 	zp_mos_OS_wksp2+1
00050Ar 1  0A           			asl	A
00050Br 1  0A           			asl	A
00050Cr 1  85 FA        			sta	zp_mos_OS_wksp2
00050Er 1  0A           			asl	A
00050Fr 1  0A           			asl	A
000510r 1  65 FA        			adc	zp_mos_OS_wksp2
000512r 1               		.if SNDBUF_BUF_0<>0
000512r 1               			adc	#SNDWKSP_BUF_0
000512r 1               		.endif
000512r 1  65 FB        			adc	zp_mos_OS_wksp2+1		; get back *1
000514r 1  85 FA        			sta	zp_mos_OS_wksp2
000516r 1  A9 FD        			lda	#>JIM
000518r 1  85 FB        			sta	zp_mos_OS_wksp2+1
00051Ar 1  28           			plp
00051Br 1  60           			rts					; exit
00051Cr 1               
00051Cr 1               
00051Cr 1               SOUND_REMV:
00051Cr 1  20 rr rr     		jsr	jimSetDEV_either_stack_old
00051Fr 1  08           		php
000520r 1  48           		pha
000521r 1  20 rr rr     		jsr	jimPageSoundWorkspace
000524r 1  AD 04 FD     		lda	JIM+SNDWKSP_OLDREMV
000527r 1  8D 00 01     		sta	$100
00052Ar 1  AD 05 FD     		lda	JIM+SNDWKSP_OLDREMV+1
00052Dr 1  8D 01 01     		sta	$101
000530r 1  68           		pla
000531r 1  28           		plp
000532r 1               
000532r 1               
000532r 1               
000532r 1               ;*************************************************************************
000532r 1               ;*									 *
000532r 1               ;*	 REMV buffer remove vector default entry point			 *
000532r 1               ;*									 *
000532r 1               ;*************************************************************************
000532r 1               ;on entry X = buffer number
000532r 1               ;on exit if buffer is empty C=1, Y is preserved else C=0
000532r 1               
000532r 1  08           _REMVB:			php					; push flags
000533r 1  78           			sei					; bar interrupts
000534r 1               
000534r 1  48           			pha					; return value
000535r 1  8A           			txa
000536r 1  48           			pha					; DB:save X
000537r 1  08           			php					; DB: extra push to save overflow round sbc
000538r 1  38           			sec
000539r 1  E9 14        			sbc	#SND_BUFFER_NUMBER_0		; get buffer base number and subtract
00053Br 1  AA           			tax
00053Cr 1  C9 08        			cmp	#SND_NUM_CHANS
00053Er 1  B0 1F        			bcs	@exitpasson
000540r 1  28           			plp
000541r 1               
000541r 1  20 rr rr     			jsr	REMV_internal
000544r 1  B0 12        			bcs	@exit_sec
000546r 1               
000546r 1  86 FA        			stx	zp_mos_OS_wksp2			; TODO: DB this is convoluted - have a think
000548r 1  BA           			tsx
000549r 1  9D 02 01     			sta	$102,X
00054Cr 1  A6 FA        			ldx	zp_mos_OS_wksp2			; DB: note we need to stack A for return faff
00054Er 1               
00054Er 1  68           			pla
00054Fr 1  AA           			tax
000550r 1  68           			pla					; get back result
000551r 1  A8           			tay					; copy to Y
000552r 1  28           			plp
000553r 1  18           			clc					; clear carry to indicate success
000554r 1  20 rr rr     @unstackrts:		jsr	jimUnStackDev			; unstack device and exit
000557r 1  60           			rts					; DB: NOTE do not remove this the jimUnStackDev does funky shit with the stack
000558r 1               
000558r 1               
000558r 1  68           @exit_sec:		pla
000559r 1  AA           			tax
00055Ar 1  68           			pla
00055Br 1  28           			plp
00055Cr 1  38           			sec
00055Dr 1  B0 F5        			bcs	@unstackrts
00055Fr 1               
00055Fr 1               @exitpasson:
00055Fr 1  28           			plp					; unstack V
000560r 1  68           			pla
000561r 1  AA           			tax
000562r 1  68           			pla
000563r 1  28           			plp					; unstack I
000564r 1               
000564r 1  20 rr rr     			jsr	jimUnStackDev
000567r 1  6C 00 01     			jmp	($100)
00056Ar 1               
00056Ar 1               
00056Ar 1               
00056Ar 1               ; check for empty buffer
00056Ar 1               REMV_internal_SEV:
00056Ar 1  2C rr rr     			bit	_BD9B7				; set V
00056Dr 1  70 01        			bvs	REMV_internal
00056Fr 1               REMV_internal_CLV:
00056Fr 1  B8           			clv
000570r 1               REMV_internal:
000570r 1  BD 28 FD     			lda	JIM+SNDWKSP_BUF_OUT_0,X		; get output pointer for buffer X
000573r 1  DD 30 FD     			cmp	JIM+SNDWKSP_BUF_IN_0,X		; compare to input pointer
000576r 1  D0 02        			bne	@s1				; if equal buffer is empty so E4E0 to exit
000578r 1  38           			sec
000579r 1  60           			rts
00057Ar 1  A8           @s1:			tay					; else Y=A
00057Br 1  20 rr rr     			jsr	_GET_BUFFER_ADDRESS		; and get buffer pointer into FA/B
00057Er 1  B1 FA        			lda	(zp_mos_OS_wksp2),Y		; read byte from buffer
000580r 1               
000580r 1               ;; DB: fixed as per MOS 2.x, returns the next char instead of pointer
000580r 1               ;;			bvc	@noty
000580r 1               ;;			tya					; return pointer instead of byte!
000580r 1               ;;@noty:
000580r 1               
000580r 1  48           			pha					; save returned byte
000581r 1  20 rr rr     			jsr	jimPageSoundWorkspace
000584r 1  70 15        			bvs	@retV				; if V is set (on input) exit with CARRY clear
000586r 1               								; Osbyte 152 has been done
000586r 1               								; else must be osbyte 145 so save byte
000586r 1               
000586r 1               
000586r 1  C8           			iny					; increment Y
000587r 1  98           			tya					; A=Y
000588r 1  C0 15        			cpy	#SND_BUF_LEN
00058Ar 1  D0 02        			bne	@_BE47E				; if end of buffer not reached  E47E
00058Cr 1               
00058Cr 1  A9 00        			lda	#0
00058Er 1               
00058Er 1               @_BE47E:
00058Er 1  9D 28 FD     			sta	JIM+SNDWKSP_BUF_OUT_0,X		; set buffer output pointer
000591r 1               
000591r 1  DD 30 FD     			cmp	JIM+SNDWKSP_BUF_IN_0,X		; else for output buffers compare with buffer start
000594r 1  D0 05        			bne	@_BE48F				; if not the same buffer is not empty so E48F
000596r 1               
000596r 1               
000596r 1  A0 00        			ldy	#$00				; buffer is empty so Y=0
000598r 1  20 BF FF     			jsr	OSEVEN				; and enter EVENT routine to signal EVENT 0 buffer
00059Br 1               								; becoming empty
00059Br 1               
00059Br 1               @_BE48F:
00059Br 1  68           @retV:			pla
00059Cr 1  18           			clc
00059Dr 1  60           			rts
00059Er 1               
00059Er 1               
00059Er 1               
00059Er 1               
00059Er 1               
00059Er 1               SOUND_CNPV:
00059Er 1  20 rr rr     		jsr	jimSetDEV_either_stack_old
0005A1r 1  08           		php
0005A2r 1  48           		pha
0005A3r 1  20 rr rr     		jsr	jimPageSoundWorkspace
0005A6r 1  AD 06 FD     		lda	JIM+SNDWKSP_OLDCNPV
0005A9r 1  8D 00 01     		sta	$100
0005ACr 1  AD 07 FD     		lda	JIM+SNDWKSP_OLDCNPV+1
0005AFr 1  8D 01 01     		sta	$101
0005B2r 1  68           		pla
0005B3r 1  28           		plp
0005B4r 1               
0005B4r 1               
0005B4r 1               ;*************************************************************************
0005B4r 1               ;*									 *
0005B4r 1               ;*	 COUNT PURGE VECTOR	 DEFAULT ENTRY				 *
0005B4r 1               ;*									 *
0005B4r 1               ;*************************************************************************
0005B4r 1               ;on entry if V set clear buffer
0005B4r 1               ;	  if C set get space left
0005B4r 1               ;	  else get bytes used
0005B4r 1               
0005B4r 1               
0005B4r 1               
0005B4r 1               
0005B4r 1               
0005B4r 1  08           _CNPV:			php
0005B5r 1  78           			sei
0005B6r 1  48           			pha					; return value
0005B7r 1  8A           			txa
0005B8r 1  48           			pha					; DB:save X
0005B9r 1  08           			php					; DB: extra push to save overflow round sbc
0005BAr 1  38           			sec
0005BBr 1  E9 14        			sbc	#SND_BUFFER_NUMBER_0		; get buffer base number and subtract
0005BDr 1  AA           			tax
0005BEr 1  C9 08        			cmp	#SND_NUM_CHANS
0005C0r 1  B0 2D        			bcs	@exitpasson
0005C2r 1  28           			plp
0005C3r 1               
0005C3r 1  50 08        			bvc	@_BE1DA				; if bit 6 is set then E1DA
0005C5r 1  BD 28 FD     			lda	JIM+SNDWKSP_BUF_OUT_0,X		; else start of buffer=end of buffer
0005C8r 1  9D 30 FD     			sta	JIM+SNDWKSP_BUF_IN_0,X		;
0005CBr 1  70 1A        			bvs	@ret				; and exit
0005CDr 1               
0005CDr 1  08           @_BE1DA:		php					; push flags
0005CEr 1  38           			sec					; set carry
0005CFr 1  BD 30 FD     			lda	JIM+SNDWKSP_BUF_IN_0,X		; get end of buffer
0005D2r 1  FD 28 FD     			sbc	JIM+SNDWKSP_BUF_OUT_0,X		; subtract start of buffer
0005D5r 1  B0 02        			bcs	@_BE1EA				; if carry caused E1EA
0005D7r 1               								;
0005D7r 1  69 15        			adc	#SND_BUF_LEN			; add buffer length
0005D9r 1  28           @_BE1EA:		plp					; pull flags
0005DAr 1  90 05        			bcc	@_BE1F3				; if carry clear E1F3 to exit
0005DCr 1  49 FF        			eor	#$FF
0005DEr 1  18           			clc					; clear carry
0005DFr 1  69 15        			adc	#SND_BUF_LEN			; adc to get bytes used
0005E1r 1  A0 00        @_BE1F3:		ldy	#$00				; Y=0
0005E3r 1  AA           			tax					; X=A
0005E4r 1  68           			pla					; DB: stack buggery to get X out
0005E5r 1  8A           			txa
0005E6r 1  48           			pha
0005E7r 1               
0005E7r 1  68           @ret:			pla
0005E8r 1  AA           			tax
0005E9r 1  68           			pla
0005EAr 1  28           			plp					; get back flags
0005EBr 1  20 rr rr     			jsr	jimUnStackDev
0005EEr 1  60           			rts					; and exit
0005EFr 1               
0005EFr 1               @exitpasson:
0005EFr 1  28           		plp
0005F0r 1  68           		pla
0005F1r 1  AA           		tax
0005F2r 1  68           		pla
0005F3r 1  28           		plp
0005F4r 1  20 rr rr     		jsr	jimUnStackDev
0005F7r 1  6C 00 01     		jmp	($100)
0005FAr 1               
0005FAr 1               
0005FAr 1               
0005FAr 1               ;*************************************************************************
0005FAr 1               ;*									 *
0005FAr 1               ;*	 PROCESS SOUND INTERRUPT					 *
0005FAr 1               ;*									 *
0005FAr 1               ;*************************************************************************
0005FAr 1               
0005FAr 1               
0005FAr 1               		.import _SOUND_IRQ
0005FAr 1               
0005FAr 1               sound_irq:
0005FAr 1  20 rr rr     		jsr	jimPageSoundWorkspace
0005FDr 1  AD 00 FD     		lda	JIM+SNDWKSP_SOUNDFLAGS
000600r 1  30 03        		bmi	@s1
000602r 1  4C rr rr     		jmp	ServiceOut
000605r 1               @s1:
000605r 1  20 rr rr     		jsr	_SOUND_IRQ
000608r 1               
000608r 1               		; clear pending IRQ
000608r 1  A9 C0        		lda	#VIA_IFR_BIT_T1+VIA_IFR_BIT_ANY
00060Ar 1  8D 6D FE     		sta	sheila_USRVIA_ifr
00060Dr 1  4C rr rr     		jmp	ServiceOutA0
000610r 1               
000610r 1               
000610r 1  20 rr rr     cmdSoundSamMap:	jsr	jimPageSoundWorkspace
000613r 1               
000613r 1  AD 00 FD     		lda	JIM+SNDWKSP_SOUNDFLAGS
000616r 1  10 49        		bpl	@brkSoundNotEn
000618r 1               
000618r 1  20 rr rr     		jsr	SkipSpacesPTR
00061Br 1  C9 0D        		cmp	#$D
00061Dr 1  D0 45        		bne	@sk1
00061Fr 1               		; no parameters - list samples mappings
00061Fr 1               
00061Fr 1  A2 rr        		ldx	#<str_SAM_MAP_HDR
000621r 1  A0 rr        		ldy	#>str_SAM_MAP_HDR
000623r 1  20 rr rr     		jsr	PrintXY
000626r 1               
000626r 1  A2 00        		ldx	#0
000628r 1  8A           @lp:		txa
000629r 1  20 rr rr     		jsr	PrintHexA
00062Cr 1  A9 20        		lda	#' '
00062Er 1  A0 06        		ldy	#6
000630r 1  20 E3 FF     @lp2:		jsr	OSASCI
000633r 1  88           		dey
000634r 1  D0 FA        		bne	@lp2
000636r 1  BD C0 FD     		lda	JIM+SNDWKSP_DEF_SAM,X
000639r 1  10 22        		bpl	@dash
00063Br 1  29 1F        		and	#$1F
00063Dr 1  18           		clc
00063Er 1  69 01        		adc	#1
000640r 1  20 rr rr     		jsr	PrintHexA
000643r 1  A8           		tay
000644r 1  20 rr rr     		jsr	jimPageSamTbl
000647r 1  B9 01 FD     		lda	JIM+SAMTBLOFFS_BASE+1,Y
00064Ar 1  10 05        		bpl	@oks
00064Cr 1  A9 21        		lda	#'!'
00064Er 1  20 EE FF     @dash2:		jsr	OSWRCH
000651r 1  20 rr rr     @oks:		jsr	jimPageSoundWorkspace
000654r 1  20 E7 FF     		jsr	OSNEWL
000657r 1  E8           		inx
000658r 1  E0 08        		cpx	#SND_NUM_CHANS
00065Ar 1  D0 CC        		bne	@lp
00065Cr 1  60           		rts
00065Dr 1  A9 2D        @dash:		lda	#'-'
00065Fr 1  D0 ED        		bne	@dash2
000661r 1               
000661r 1  4C rr rr     @brkSoundNotEn:	jmp	brkSoundNotEn
000664r 1               
000664r 1  20 rr rr     @sk1:		jsr	ParseHex
000667r 1  B0 1C        		bcs	brkBadCommand2
000669r 1  A5 AC        		lda	zp_trans_acc
00066Br 1  C9 08        		cmp	#SND_NUM_CHANS
00066Dr 1  B0 16        		bcs	brkBadCommand2
00066Fr 1  AA           		tax				; X now contains channel #
000670r 1  20 rr rr     		jsr	ParseHex
000673r 1  B0 10        		bcs	brkBadCommand2
000675r 1  A5 AC        		lda	zp_trans_acc
000677r 1  F0 0C        		beq	brkBadCommand2
000679r 1  C9 21        		cmp	#33
00067Br 1  B0 08        		bcs	brkBadCommand2
00067Dr 1  E9 00        		sbc	#0
00067Fr 1  09 80        		ora	#$80			; mark in use
000681r 1  9D C0 FD     		sta	JIM+SNDWKSP_DEF_SAM,X
000684r 1  60           		rts
000685r 1  4C rr rr     brkBadCommand2:	jmp	brkBadCommand
000688r 1               
000688r 1               
000688r 1               cmdSoundSamClear:
000688r 1  20 rr rr     		jsr	SkipSpacesPTR
00068Br 1  C9 2A        		cmp	#'*'
00068Dr 1  F0 0B        		beq	@skclearall
00068Fr 1  20 rr rr     		jsr	ParseHex
000692r 1  B0 F1        		bcs	brkBadCommand2
000694r 1  A6 AC        		ldx	zp_trans_acc+0
000696r 1  4C rr rr     		jmp	@clrone
000699r 1  60           		rts
00069Ar 1  A2 20        @skclearall:	ldx	#32
00069Cr 1  20 rr rr     @lp:		jsr	@clrone
00069Fr 1  CA           		dex
0006A0r 1  D0 FA        		bne	@lp
0006A2r 1               
0006A2r 1  8A           @clrone:	txa
0006A3r 1  48           		pha
0006A4r 1  CA           		dex
0006A5r 1  8A           		txa
0006A6r 1  29 E0        		and	#$E0
0006A8r 1  D0 2D        		bne	@skip
0006AAr 1  8A           		txa
0006ABr 1  0A           		asl	A
0006ACr 1  0A           		asl	A
0006ADr 1  0A           		asl	A
0006AEr 1  AA           		tax
0006AFr 1  20 rr rr     		jsr	jimPageSamTbl
0006B2r 1  BD 01 FD     		lda	JIM+SAMTBLOFFS_BASE+1,X
0006B5r 1  30 20        		bmi	@skip
0006B7r 1               
0006B7r 1  48           		pha
0006B8r 1  A9 FF        		lda	#$FF
0006BAr 1  9D 01 FD     		sta	JIM+SAMTBLOFFS_BASE+1,X		; mark sample freed
0006BDr 1  BD 00 FD     		lda	JIM+SAMTBLOFFS_BASE,X
0006C0r 1  48           		pha
0006C1r 1  A9 11        		lda	#OSWORD_OP_FREE
0006C3r 1  48           		pha
0006C4r 1  A9 00        		lda	#0
0006C6r 1  48           		pha
0006C7r 1  A9 05        		lda	#5
0006C9r 1  BA           		tsx
0006CAr 1  48           		pha
0006CBr 1  A0 01        		ldy	#1			; pass parameters from stack, call Heap free
0006CDr 1  A9 99        		lda	#OSWORD_BLTUTIL
0006CFr 1  20 F1 FF     		jsr	OSWORD
0006D2r 1  68           		pla
0006D3r 1  68           		pla
0006D4r 1  68           		pla
0006D5r 1  68           		pla
0006D6r 1  68           		pla
0006D7r 1               
0006D7r 1  68           @skip:		pla
0006D8r 1  AA           		tax
0006D9r 1  60           		rts
0006DAr 1               
0006DAr 1               
0006DAr 1               
0006DAr 1               		.SEGMENT "RODATA"
000000r 1               
000000r 1  43 68 61 6E  str_SAM_MAP_HDR:	.byte	"Channel Sample#",13
000004r 1  6E 65 6C 20  
000008r 1  53 61 6D 70  
000010r 1  2D 2D 2D 2D  			.byte	"---------------",13,0
000014r 1  2D 2D 2D 2D  
000018r 1  2D 2D 2D 2D  
000021r 1  50 61 75 6C  str_SOUND_start:	.byte	"Paula sound started, channels: ",0
000025r 1  61 20 73 6F  
000029r 1  75 6E 64 20  
000041r 1               
000041r 1               
000041r 1               
000041r 1               SOUND_BYTEV:
000041r 1               
000041r 1  48           		pha
000042r 1  48           		pha
000043r 1  08           		php
000044r 1               
000044r 1  20 rr rr     		jsr	jimSetDEV_either_stack_old
000047r 1               
000047r 1               		; stack contains
000047r 1               		;	+5..6		spare return address
000047r 1               		;	+4		P
000047r 1               		; 	+3		previously selected device
000047r 1               		;	+2		old JIM paging register LO
000047r 1               		;	+1		old JIM paging register LO
000047r 1               
000047r 1  20 rr rr     		jsr	jimPageSoundWorkspace
00004Ar 1               
00004Ar 1  48           		pha
00004Br 1  8A           		txa
00004Cr 1  48           		pha
00004Dr 1               
00004Dr 1               		; stack contains
00004Dr 1               		;	+7..8		spare return address
00004Dr 1               		;	+6		P
00004Dr 1               		; 	+5		previously selected device
00004Dr 1               		;	+4		old JIM paging register LO
00004Dr 1               		;	+3		old JIM paging register LO
00004Dr 1               		;	+2		A
00004Dr 1               		;	+1		X
00004Dr 1               
00004Dr 1               		; make a return address that will jump to old vector
00004Dr 1               
00004Dr 1  BA           		tsx
00004Er 1  AD 08 FD     		lda	JIM+SNDWKSP_OLDBYTEV
000051r 1  9D 07 01     		sta	$107,X
000054r 1  AD 09 FD     		lda	JIM+SNDWKSP_OLDBYTEV+1
000057r 1  9D 08 01     		sta	$108,X
00005Ar 1               
00005Ar 1  68           		pla
00005Br 1  AA           		tax
00005Cr 1  68           		pla
00005Dr 1  48           		pha
00005Er 1               
00005Er 1               		; stack contains
00005Er 1               		;	+5..6		old BYTEV-1
00005Er 1               		; 	+4		previously selected device
00005Er 1               		;	+3		old JIM paging register LO
00005Er 1               		;	+2		old JIM paging register LO
00005Er 1               		;	+1		A
00005Er 1               
00005Er 1  C9 7E        		cmp	#OSBYTE_126_ESCAPE_ACK
000060r 1  F0 0D        		beq	@osbyte_ackesc
000062r 1  C9 0F        		cmp	#OSBYTE_15_FLUSH_INPUT
000064r 1  F0 14        		beq	@flushall
000066r 1  C9 15        		cmp	#OSBYTE_21_FLUSH_BUFFER
000068r 1  F0 28        		beq	@flushone
00006Ar 1               
00006Ar 1               @exitpasson:
00006Ar 1  68           		pla
00006Br 1  20 rr rr     		jsr	jimUnStackDev
00006Er 1  40           		rti					; return to address we pushed above (don't jmp to jimunstackdev!)
00006Fr 1               
00006Fr 1               
00006Fr 1  24 FF        @osbyte_ackesc:	bit	zp_mos_ESC_flag			; if bit 7 not set there is no ESCAPE condition
000071r 1  10 F7        		bpl	@exitpasson			; so E673
000073r 1  AD 76 02     		lda	sysvar_KEYB_ESC_EFFECT		; else get ESCAPE Action, if this is 0
000076r 1               							; Clear ESCAPE
000076r 1               							; close EXEC files
000076r 1               							; purge all buffers
000076r 1               							; reset VDU paging counter
000076r 1  D0 F2        		bne	@exitpasson			; else do none of the above
000078r 1  F0 03        		beq	@doflushall
00007Ar 1  8A           @flushall:	txa
00007Br 1  D0 ED        		bne	@exitpasson
00007Dr 1  8A           @doflushall:	txa
00007Er 1  48           		pha
00007Fr 1  A9 15        		lda	#OSBYTE_21_FLUSH_BUFFER
000081r 1  A2 14        		ldx	#SND_BUFFER_NUMBER_0
000083r 1               @lp1:
000083r 1  58           		cli
000084r 1  78           		sei
000085r 1  20 F4 FF     		jsr	OSBYTE
000088r 1  E8           		inx
000089r 1  E0 1C        		cpx	#SND_BUFFER_NUMBER_0+SND_NUM_CHANS
00008Br 1  90 F6        		bcc	@lp1
00008Dr 1               
00008Dr 1  68           		pla
00008Er 1  AA           		tax
00008Fr 1  4C rr rr     		jmp	@exitpasson
000092r 1               
000092r 1  E0 14        @flushone:	cpx	#SND_BUFFER_NUMBER_0
000094r 1  90 D4        		bcc	@exitpasson
000096r 1  E0 1C        		cpx	#SND_BUFFER_NUMBER_0+SND_NUM_CHANS
000098r 1  B0 D0        		bcs	@exitpasson
00009Ar 1               
00009Ar 1  98           		tya
00009Br 1  48           		pha
00009Cr 1  8A           		txa
00009Dr 1  48           		pha
00009Er 1               
00009Er 1  38           		sec
00009Fr 1  E9 14        		sbc	#SND_BUFFER_NUMBER_0
0000A1r 1  AA           		tax
0000A2r 1  20 rr rr     		jsr	_LECA2				; silence channel X
0000A5r 1               
0000A5r 1  38           		sec
0000A6r 1  7E 20 FD     		ror	JIM+SNDWKSP_BUF_BUSY_0,X	; mark as not busy
0000A9r 1               
0000A9r 1  68           		pla
0000AAr 1  48           		pha
0000ABr 1  AA           		tax					; get back original X
0000ACr 1               
0000ACr 1  2C rr rr     		bit	@v				; set V
0000AFr 1  20 rr rr     		jsr	__CNPV
0000B2r 1               
0000B2r 1  68           		pla
0000B3r 1  AA           		tax
0000B4r 1  68           		pla
0000B5r 1  A8           		tay
0000B6r 1  4C rr rr     		jmp	@exitpasson
0000B9r 1               
0000B9r 1  40           @v:		.byte $40
0000B9r 1               
